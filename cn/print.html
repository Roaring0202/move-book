<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Move编程语言</a></li><li class="chapter-item expanded "><a href="introduction/foreword.html"><strong aria-hidden="true">2.</strong> 序言</a></li><li class="chapter-item expanded "><a href="introduction/getting-started.html"><strong aria-hidden="true">3.</strong> 快速入门</a></li><li class="chapter-item expanded "><a href="syntax-basics/index.html"><strong aria-hidden="true">4.</strong> 语法基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax-basics/concept.html"><strong aria-hidden="true">4.1.</strong> 基础概念</a></li><li class="chapter-item expanded "><a href="syntax-basics/primitives.html"><strong aria-hidden="true">4.2.</strong> 基本类型</a></li><li class="chapter-item expanded "><a href="syntax-basics/comments.html"><strong aria-hidden="true">4.3.</strong> 注释</a></li><li class="chapter-item expanded "><a href="syntax-basics/expression-and-scope.html"><strong aria-hidden="true">4.4.</strong> 表达式和作用域</a></li><li class="chapter-item expanded "><a href="syntax-basics/control-flow.html"><strong aria-hidden="true">4.5.</strong> 控制流</a></li><li class="chapter-item expanded "><a href="syntax-basics/module.html"><strong aria-hidden="true">4.6.</strong> 模块和导入</a></li><li class="chapter-item expanded "><a href="syntax-basics/constants.html"><strong aria-hidden="true">4.7.</strong> 常量</a></li><li class="chapter-item expanded "><a href="syntax-basics/function.html"><strong aria-hidden="true">4.8.</strong> 函数</a></li><li class="chapter-item expanded "><a href="syntax-basics/struct.html"><strong aria-hidden="true">4.9.</strong> 结构体</a></li></ol></li><li class="chapter-item expanded "><a href="advanced-topics/index.html"><strong aria-hidden="true">5.</strong> 进阶主题</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced-topics/ownership-and-references.html"><strong aria-hidden="true">5.1.</strong> 所有权和引用</a></li><li class="chapter-item expanded "><a href="advanced-topics/understanding-generics.html"><strong aria-hidden="true">5.2.</strong> 泛型</a></li><li class="chapter-item expanded "><a href="advanced-topics/managing-collections-with-vectors.html"><strong aria-hidden="true">5.3.</strong> 数组</a></li></ol></li><li class="chapter-item expanded "><a href="resources/index.html"><strong aria-hidden="true">6.</strong> 可编程的 Resource</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="resources/signer-type.html"><strong aria-hidden="true">6.1.</strong> 发送者和签署者</a></li><li class="chapter-item expanded "><a href="resources/what-is-resource.html"><strong aria-hidden="true">6.2.</strong> 什么是 Resource</a></li><li class="chapter-item expanded "><a href="resources/resource-by-example.html"><strong aria-hidden="true">6.3.</strong> Resource 举例</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="resources/storing-new-resource.html"><strong aria-hidden="true">6.3.1.</strong> 创建和转移</a></li><li class="chapter-item expanded "><a href="resources/access-resource-with-borrow.html"><strong aria-hidden="true">6.3.2.</strong> 读取和修改</a></li><li class="chapter-item expanded "><a href="resources/destroy-resource.html"><strong aria-hidden="true">6.3.3.</strong> 使用和销毁</a></li><li class="chapter-item expanded "><a href="resources/furher-steps.html"><strong aria-hidden="true">6.3.4.</strong> 下一步</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="tutorials/index.html"><strong aria-hidden="true">7.</strong> 实例</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/erc20.html"><strong aria-hidden="true">7.1.</strong> ERC20 代币</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#move-编程语言" id="move-编程语言">Move 编程语言</a></h1>
<p>Move是 <a href="https://diem.com/">Diem</a> 为区块链开发的一种安全可靠的语言。您可以在 <a href="https://developers.libra.org/docs/assets/papers/libra-move-a-language-with-programmable-resources/2019-09-26.pdf">Diem developers website</a> 找到它的白皮书，也可以在<a href="https://community.diem.com/t/introducing-the-move-programming-language/72/45">社区</a> 找到更多内容，了解为什么Move更适合区块链。</p>
<p>作为一种刚刚诞生的语言，介绍它的信息不是很多。我把自己收集到的信息加工、汇总，以书本的形式呈现给读者，便于大家参考。 </p>
<h1><a class="header" href="#前言" id="前言">前言</a></h1>
<p>当我写这本书时，还没有关于Move语言的文档（或其他参考资料），我的目标是使人们有机会看到加密货币世界的隐藏瑰宝-Move语言。目前，语言开发人员已经编写了<a href="https://developers.diem.com/docs/move/overview">Move文档</a> ，但是我仍然认为本书中的流程对于新手来说更直观，更友好。我也曾经是新手，而Move是一种棘手且有趣的语言，其中某些概念非常新颖，简直令人难以置信。</p>
<p>我非常喜欢这种语言，希望您能明白原因！</p>
<p>- Damir Shamanaev</p>
<p><em>这本书是我在<a href="https://dfinance.co">dfinance</a>工作时写的。</em></p>
<h1><a class="header" href="#快速入门" id="快速入门">快速入门</a></h1>
<p>与任何编程语言一样，Move应用程序也需要一组适当的工具来编译，运行和调试。由于Move语言是为区块链创建、并且仅在区块链中使用，因此在链外运行程序不是一件容易的事，因为每个应用都需要一个编辑环境，账户处理和编译-发布系统。</p>
<p>为了简化Move程序的开发，我在Visual Studio Code上开发了<a href="https://github.com/damirka/vscode-move-ide">Move IDE</a> 扩展。该扩展可以满足开发者对开发环境的基本需求，它的功能包括Move语法突出显示和程序执行，以帮助开发者在发布之前调试应用程序。使用它后开发者可以专注于学习Move语言，而不必为客户端（CLI）苦苦挣扎。</p>
<h2><a class="header" href="#安装-move-ide" id="安装-move-ide">安装 Move IDE</a></h2>
<p>需要安装下面的软件:</p>
<ol>
<li>VSCode (1.43.0 或者更高版本) - 可以在 <a href="https://code.visualstudio.com/download">这里</a> 获取; 当然如果你的机器上已经安装了VSCode，可以直接进入下一步;</li>
<li>Move IDE - 安装VSCode后，请单击 <a href="https://marketplace.visualstudio.com/items?itemName=damirka.move-ide">这里</a> 安装最新版本的IDE。</li>
</ol>
<h3><a class="header" href="#环境设置" id="环境设置">环境设置</a></h3>
<p>Move IDE提供了单一的方法来组织目录结构。只需要创建一个新目录，并在VSCode中打开它，就可以得到如下目录结构：</p>
<pre><code>modules/   - directory for our modules
scripts/   - directory for transaction scripts
out/       - this directory will hold compiled sources
</code></pre>
<p>另外，还需要创建一个名为<code>.mvconfig.json</code>的文件，该文件将配置您的工作环境。下面这个配置指向了<code>天秤座</code>网络:</p>
<pre><code class="language-json">{
    &quot;network&quot;: &quot;libra&quot;,
    &quot;sender&quot;: &quot;0x1&quot;
}
</code></pre>
<p>或者使用<code>dfinance</code>作为目标网络:</p>
<pre><code class="language-json">{
    &quot;network&quot;: &quot;dfinance&quot;,
    &quot;sender&quot;: &quot;0x1&quot;
}
</code></pre>
<blockquote>
<p>dfinance使用bech32&quot;wallet1 ...&quot;地址，天秤座使用16字节“0x ...”地址。对于本地运行或者测试，使用天秤座地址就可以了。但是在测试网或生产环境中使用真实的区块链时，需要使用所选网络的正确地址。</p>
</blockquote>
<h2><a class="header" href="#第一个move应用" id="第一个move应用">第一个Move应用</a></h2>
<p>Move IDE使开发者可以在测试环境中运行程序。让我们通过一个例子，实现gimme_five()功能并在VSCode中运行它，来了解其工作原理。</p>
<h3><a class="header" href="#创建模块" id="创建模块">创建模块</a></h3>
<p>在项目的目录modules/内创建一个新文件hello_world.move。</p>
<pre><code class="language-Move">// modules/hello_world.move
address 0x1 {
module HelloWorld {
    public fun gimme_five(): u8 {
        5
    }
}
}
</code></pre>
<blockquote>
<p>如果您想使用自己的地址（而非0x1），请确保更改此文件中的0x1以及下面文件中的地址</p>
</blockquote>
<h3><a class="header" href="#写脚本" id="写脚本">写脚本</a></h3>
<p>然后在scripts/目录中创建一个脚本me.move，调用上面的模块：</p>
<pre><code class="language-Move">// scripts/run_hello.move
script {
    use 0x1::HelloWorld;
    use 0x1::Debug;

    fun main() {
        let five = HelloWorld::gimme_five();

        Debug::print&lt;u8&gt;(&amp;five);
    }
}
</code></pre>
<p>然后，在保持脚本打开的同时，执行以下步骤：</p>
<p>1.通过按<code>⌘+Shift+P</code>（在Mac上）或<code>Ctrl+Shift+P</code>（在Linux / Windows上）来切换VSCode的命令选项板
2.键入：<code>&gt;Move: Run Script</code>并在看到正确的选项时按Enter或单击。
现在，你应该会看到执行结果，输出日志中有“5”信息。如果没有看到此窗口，请再次浏览上面部分，看看有没有漏掉什么。</p>
<p>目录结构应如下所示：</p>
<pre><code>modules/
  hello_world.move
scripts/
  run_hello.move
out/
.mvconfig.json
</code></pre>
<blockquote>
<p>modules目录下可以包含任意多的模块；所有这些模块都可以被你的脚本访问到，只要它们都被定义在.mvconfig.json所指定的地址下。</p>
</blockquote>
<h1><a class="header" href="#语法基础" id="语法基础">语法基础</a></h1>
<p>在本章中，您将会了解Move语言的语法。我们将从简单的基本语法规则开始，逐渐增加难度。如果您是一位熟练的开发者，这些内容似乎比较容易，但是我还是建议您花时间看一下。如果您是初学者，那么这部分内容将为您提供掌握Move基础知识所需的一切。</p>
<h1><a class="header" href="#基础概念" id="基础概念">基础概念</a></h1>
<p>与其它区块链语言（例如Solidity）不同，Move程序分为脚本（或交易脚本）和模块。前者可以让您在交易中加入更多逻辑，在更加灵活的同时节省时间和资源。后者允许开发人员更容易扩展区块链的功能，更加灵活的实现自定义智能合约。</p>
<p>下面，我们将从脚本开始学习，因为它对新手来说非常友好，然后我们再进一步介绍模块。</p>
<h1><a class="header" href="#基本类型" id="基本类型">基本类型</a></h1>
<p>Move用内建的基本数据类型来表示数字、布尔型和地址: 整型 (u8, u64, u128)，<code>boolean</code>和<code>address</code>。</p>
<p>Move没有字符串类型或浮点数。</p>
<h2><a class="header" href="#整型" id="整型">整型</a></h2>
<p>整型包括<code>u8</code>，<code>u64</code>和<code>u128</code>，我们通过下面的例子来理解整型：</p>
<pre><code class="language-Move">script {
    fun main() {
        // define empty variable, set value later
        let a: u8;
        a = 10;

        // define variable, set type
        let a: u64 = 10;

        // finally simple assignment
        let a = 10;

        // simple assignment with defined value type
        let a = 10u128;

        // in function calls or expressions you can use ints as constant values
        if (a &lt; 10) {};

        // or like this, with type
        if (a &lt; 10u8) {}; // usually you don't need to specify type
    }
}
</code></pre>
<h3><a class="header" href="#运算符as" id="运算符as">运算符<code>as</code></a></h3>
<p>当需要比较值的大小或者当函数需要输入不同大小的整型参数时，你可以使用<code>as</code>运算符将一种整型转换成另外一种整型：</p>
<pre><code class="language-Move">script {
    fun main() {
        let a: u8 = 10;
        let b: u64 = 100;

        // we can only compare same size integers
        if (a == (b as u8)) abort 11;
        if ((a as u64) == b) abort 11;
    }
}
</code></pre>
<h2><a class="header" href="#布尔型" id="布尔型">布尔型</a></h2>
<p>布尔类型就像惯用那样，包含<code>false</code>和<code>true</code>两个值。</p>
<pre><code class="language-Move">script {
    fun main() {
        // these are all the ways to do it
        let b : bool; b = true;
        let b : bool = true;
        let b = true
        let b = false; // here's an example with false
    }
}
</code></pre>
<h2><a class="header" href="#地址" id="地址">地址</a></h2>
<p>地址是区块链中交易发送者（或钱包）的标识符，转账和导入模块这些基本的操作都离不开地址。</p>
<pre><code class="language-Move">script {
    fun main() {
        let addr: address; // type identifier

        // in this book I'll use {{sender}} notation;
        // always replace `{{sender}}` in examples with VM specific address!!!
        addr = {{sender}};

        // in Diem's Move VM - 16-byte address in HEX
        addr = 0x...;

        // in dfinance's DVM - bech32 encoded address with `wallet1` prefix
        addr = wallet1....;
    }
}
</code></pre>
<h1><a class="header" href="#注释" id="注释">注释</a></h1>
<p>如果您觉得代码中某些地方需要额外说明，请使用注释。注释是不参与执行的文本块或行，旨在描述相关代码。</p>
<h3><a class="header" href="#行注释" id="行注释">行注释</a></h3>
<pre><code class="language-Move">script {
    fun main() {
        // this is a comment line
    }
}
</code></pre>
<p>可以使用双斜杠“//”编写行注释。规则很简单 - “//”之后到行尾的所有内容均视为注释。也可以使用行注释为其他开发人员留下简短消息，或者注释掉一些代码使之不参与执行。</p>
<pre><code class="language-Move">script {
    // let's add a note to everything!
    fun main() {
        let a = 10;
        // let b = 10 this line is commented and won't be executed
        let b = 5; // here comment is placed after code
        a + b // result is 15, not 10!
    }
}
</code></pre>
<h3><a class="header" href="#块注释" id="块注释">块注释</a></h3>
<p>如果不想注释整行内容，或者想要注释掉多行，则可以使用块注释。</p>
<p>块注释以&quot;/*&quot;开头，并包含第一个&quot;*/&quot;之前的所有文本。块注释不受行的限制，代码中的任何位置都可以注释。</p>
<pre><code class="language-Move">script {
    fun /* you can comment everywhere */ main() {
        /* here
           there
           everywhere */ let a = 10;
        let b = /* even here */ 10; /* and again */
        a + b
    }
    /* you can use it to remove certain expressions or definitions
    fun empty_commented_out() {

    }
    */
}
</code></pre>
<p>当然这个例子太荒谬了！但这也清楚地显示了块注释的功能，即随时随地添加说明。</p>
<!-- ### Documentation comments -->
<h1><a class="header" href="#表达式和作用域" id="表达式和作用域">表达式和作用域</a></h1>
<p>在编程语言中，表达式是返回值的代码单元。具有返回值的函数调用是一个表达式，它有返回值；整数常数也是一个表达式-它具有整数类型的值，依此类推。</p>
<blockquote>
<p>表达式必须用分号&quot;;&quot;隔开</p>
</blockquote>
<h3><a class="header" href="#空表达式" id="空表达式">空表达式</a></h3>
<p>类似于Rust，Move中的空表达式用空括号表示：</p>
<pre><code class="language-Move">script {
    fun empty() {
        () // this is an empty expression
    }
}
</code></pre>
<h3><a class="header" href="#文字表达式" id="文字表达式">文字表达式</a></h3>
<p>下面的代码，每行包含一个以分号结尾的表达式。最后一行包含三个表达式，由分号隔开。</p>
<pre><code class="language-Move">script {
    fun main() {
        10;
        10 + 5;
        true;
        true != false;
        0x1;
        1; 2; 3
    }
}
</code></pre>
<p>现在我们已经知道了最简单的表达式。但是为什么我们需要它们？以及如何使用它们？这就需要介绍let关键字了。</p>
<h3><a class="header" href="#变量和let关键字" id="变量和let关键字">变量和<code>let</code>关键字</a></h3>
<p>关键字let用来将表达式的值存储在变量中，以便于将其传递到其它地方。我们曾经在基本类型章节中使用过let，它用来创建一个新变量，该变量要么为空（未定义），要么为某表达式的值。</p>
<pre><code class="language-Move">script {
    fun main() {
        let a;
        let b = true;
        let c = 10;
        let d = 0x1;
        a = c;
    }
}
</code></pre>
<blockquote>
<p>关键字let会在<em>当前作用域</em>内创建新变量，并可以选择<em>初始化</em>此变量。该表达式的语法是：let <VARIABLE> : <TYPE>;或let <VARIABLE> = <EXPRESSION>。</p>
</blockquote>
<p>创建和初始化变量后，就可以使用变量名来<em>修改</em>或<em>访问</em>它所代表的值了。在上面的示例中，变量a在函数末尾被初始化，并被<em>分配</em>了一个值 c。</p>
<blockquote>
<p>等号&quot;=&quot;是赋值运算符。它将右侧表达式赋值给左侧变量。示例：a = 10 表示将整数10赋值给变量a。</p>
</blockquote>
<h3><a class="header" href="#整型运算符" id="整型运算符">整型运算符</a></h3>
<p>Move具有多种用于修改整数值的运算符：</p>
<table><thead><tr><th>运算符</th><th>操作</th><th>类型</th><th></th></tr></thead><tbody>
<tr><td>+</td><td>sum</td><td>uint</td><td>LHS加上RHS</td></tr>
<tr><td>-</td><td>sub</td><td>uint</td><td>从LHS减去RHS</td></tr>
<tr><td>/</td><td>div</td><td>uint</td><td>用LHS除以RHS</td></tr>
<tr><td>*</td><td>mul</td><td>uint</td><td>LHS乘以RHS</td></tr>
<tr><td>%</td><td>mod</td><td>uint</td><td>LHS除以RHS的余数</td></tr>
<tr><td>&lt;&lt;</td><td>lshift</td><td>uint</td><td>LHS左移RHS位</td></tr>
<tr><td>&gt;&gt;</td><td>rshift</td><td>uint</td><td>LHS右移RHS位</td></tr>
<tr><td>&amp;</td><td>and</td><td>uint</td><td>按位与</td></tr>
<tr><td>^</td><td>xor</td><td>uint</td><td>按位异或</td></tr>
<tr><td>\</td><td>or</td><td>uint</td><td>按位或</td></tr>
</tbody></table>
<p><em>LHS - 左侧表达式, RHS - 右侧表达式; uint: u8, u64, u128.</em></p>
<!--

### Comparison and boolean operators

To build a bool condition by comparing values you have these operators. All of them return `bool` value and require LHS and RHS types match.

| Operator | Op     | Types |                                |
|----------|--------|-------|--------------------------------|
| ==       | equal  | any   | Check if LHS equals RHS        |
|----------|--------|-------|--------------------------------|
| =<       | equal  | any   | Check if LHS equals RHS        |
|----------|--------|-------|--------------------------------|

-->
<h3><a class="header" href="#下划线-_-表示未被使用" id="下划线-_-表示未被使用">下划线 &quot;_&quot; 表示未被使用</a></h3>
<p>Move中每个变量都必须被使用，否则代码编译不会通过, 因此我们不能初始化一个变量却不去使用它。 但是你可以用下划线来告诉编译器，这个变量是故意不被使用的。</p>
<p>例如，下面的脚本在编译时会报错：</p>
<pre><code class="language-Move">script {
    fun main() {
        let a = 1;
    }
}
</code></pre>
<p>报错:</p>
<pre><code>
    ┌── /scripts/script.move:3:13 ───
    │
 33 │         let a = 1;
    │             ^ Unused assignment or binding for local 'a'. Consider removing or replacing it with '_'
    │
</code></pre>
<p>编译器给出明确提示：用下划线来代替变量名。</p>
<pre><code class="language-Move">script {
    fun main() {
        let _ = 1;
    }
}
</code></pre>
<h3><a class="header" href="#屏蔽" id="屏蔽">屏蔽</a></h3>
<p>Move允许两次定义同一个的变量，第一个变量将会被屏蔽。但有一个要求——我们仍然需要使用被屏蔽的变量。</p>
<pre><code class="language-Move">script {
    fun main() {
        let a = 1;
        let a = 2;
        let _ = a;
    }
}
</code></pre>
<p>在上面的示例中，我们仅使用了第二个a。第一个a实际上未使用，因为a在下一行被重新定义了。所以，我们可以通过下面的修改使得这段代码正常运行。</p>
<pre><code class="language-Move">script {
    fun main() {
        let a = 1;
        let a = a + 2;
        let _ = a;
    }
}
</code></pre>
<h2><a class="header" href="#块表达式" id="块表达式">块表达式</a></h2>
<p>块表达式用花括号&quot;<em>{}</em>&quot;表示。块可以包含其它表达式（和其它块）。函数体在某种意义上也是一个块。</p>
<pre><code class="language-Move">script {
    fun block() {
        { };
        { { }; };
        true;
        {
            true;

            { 10; };
        };
        { { { 10; }; }; };
    }
}
</code></pre>
<h3><a class="header" href="#作用域" id="作用域">作用域</a></h3>
<p>如<a href="https://en.wikipedia.org/wiki/Scope_(computer_science)">Wikipedia</a>中所述，作用域是绑定生效的代码区域。换句话说，变量存在于作用域中。Move作用域是由花括号扩起来的代码块，它本质上是一个块。</p>
<blockquote>
<p>定义一个块，实际上是定义一个作用域。</p>
</blockquote>
<pre><code class="language-Move">script {
    fun scope_sample() {
        // this is a function scope
        {
            // this is a block scope inside function scope
            {
                // and this is a scope inside scope
                // inside functions scope... etc
            };
        };

        {
            // this is another block inside function scope
        };
    }
}
</code></pre>
<p>从该示例可以看出，作用域是由块（或函数）定义的。它们可以嵌套，并且可以定义多少个，数量没有限制。</p>
<h3><a class="header" href="#变量的生命周期和可见性" id="变量的生命周期和可见性">变量的生命周期和可见性</a></h3>
<p>我们前面已经介绍过关键字let的作用，它可以用来定义变量。有一点需要强调的是，该变量仅存在于变量所处的作用域内。也就是说，它在作用域之外不可访问，并在作用域结束后立即消亡。</p>
<pre><code class="language-Move">script {
    fun let_scope_sample() {
        let a = 1; // we've defined variable A inside function scope

        {
            let b = 2; // variable B is inside block scope

            {
                // variables A and B are accessible inside
                // nested scopes
                let c = a + b;

            }; // in here C dies

            // we can't write this line
            // let d = c + b;
            // as variable C died with its scope

            // but we can define another C
            let c = b - 1;

        }; // variable C dies, so does C

        // this is impossible
        // let d = b + c;

        // we can define any variables we want
        // no name reservation happened
        let b = a + 1;
        let c = b + 1;

    } // function scope ended - a, b and c are dropped and no longer accessible
}
</code></pre>
<blockquote>
<p>变量仅存在于其作用域（或块）内，当作用域结束时变量随之消亡。</p>
</blockquote>
<h3><a class="header" href="#块返回值" id="块返回值">块返回值</a></h3>
<p>上面我们了解到块是一个表达式，但是我们没有介绍为什么它是一个表达式以及块的返回值是什么。</p>
<blockquote>
<p>块可以返回一个值，如果它后面没有分号，则返回值为块内最后一个表达式的值。</p>
</blockquote>
<p>听起来不好理解，我们来看下面的例子：</p>
<pre><code class="language-Move">script {
    fun block_ret_sample() {

        // since block is an expression, we can
        // assign it's value to variable with let
        let a = {

            let c = 10;

            c * 1000  // no semicolon!
        }; // scope ended, variable a got value 10000

        let b = {
            a * 1000  // no semi!
        };

        // variable b got value 10000000

        {
            10; // see semi!
        }; // this block does not return a value

        let _ = a + b; // both a and b get their values from blocks
    }
}
</code></pre>
<blockquote>
<p>块中的最后一个表达式（不带分号）是该块的返回值。</p>
</blockquote>
<h3><a class="header" href="#小结" id="小结">小结</a></h3>
<p>我们来总结一下本章要点：</p>
<ol>
<li>每个表达式都必须以分号结尾，除非它是block的返回值。</li>
<li>关键字let使用值或表达式创建新变量，该变量的生命周期与其作用域相同。</li>
<li>块是一个可能具有也可能没有返回值的表达式。</li>
</ol>
<p>下一章我们将介绍控制流和分支语句。</p>
<h3><a class="header" href="#进一步阅读" id="进一步阅读">进一步阅读</a></h3>
<ul>
<li><a href="https://community.diem.com/t/odd-error-when-semi-is-put-after-break-or-continue/2868">Diem Community thread on empty expressions and semicolon</a></li>
</ul>
<h1><a class="header" href="#控制流" id="控制流">控制流</a></h1>
<p>通过控制流表达式，我们可以选择运行某个代码块，或者跳过某块代码而运行另一代码块。</p>
<p>Move支持if表达式和循环表达式。</p>
<!-- In Move you have two statme to control flow: by using loops (`while` and `loop`) or `if` expressions. -->
<h2><a class="header" href="#if-表达式" id="if-表达式"><code>if</code> 表达式</a></h2>
<p>if 表达式允许我们在条件为真时运行代码块，在条件为假时运行另一个代码块。</p>
<pre><code class="language-Move">script {
    use 0x1::Debug;

    fun main() {

        let a = true;

        if (a) {
            Debug::print&lt;u8&gt;(&amp;0);
        } else {
            Debug::print&lt;u8&gt;(&amp;99);
        };
    }
}
</code></pre>
<p>这个例子中，当<code>a == true</code>时打印<code>0</code>，当a是<code>false</code>时打印<code>99</code>，语法非常简单：</p>
<pre><code>if (&lt;布尔表达式&gt;) &lt;表达式&gt; else &lt;表达式&gt;;
</code></pre>
<p>if是一个表达式，我们可以在let声明中使用它。但是像所有其他表达式一样，它必须以分号结尾。</p>
<pre><code class="language-Move">script {
    use 0x1::Debug;

    fun main() {

        // try switching to false
        let a = true;
        let b = if (a) { // 1st branch
            10
        } else { // 2nd branch
            20
        };

        Debug::print&lt;u8&gt;(&amp;b);
    }
}
</code></pre>
<p>现在，b将根据a表达式为变量分配不同的值。但是if的两个分支必须返回相同的类型！否则，变量b将会具有不同种类型，这在静态类型的语言中是不允许的。在编译器术语中，这称为分支兼容性 —— 两个分支必须返回兼容（相同）类型。</p>
<p>if不一定非要和else一起使用，也可以单独使用。</p>
<pre><code class="language-Move">script {
    use 0x1::Debug;

    fun main() {

        let a = true;

        // only one optional branch
        // if a = false, debug won't be called
        if (a) {
            Debug::print&lt;u8&gt;(&amp;10);
        };
    }
}
</code></pre>
<p>但是请记住，不能在let赋值语句中使用不带分支的表达式！因为如果if不满足条件，就会导致变量未被定义，这同样是不允许的。</p>
<h2><a class="header" href="#循环表达式" id="循环表达式">循环表达式</a></h2>
<p>在Move中定义循环有两种方法：</p>
<ol>
<li><code>while</code>条件循环</li>
<li><code>loop</code>无限循环</li>
</ol>
<h3><a class="header" href="#while条件循环" id="while条件循环"><code>while</code>条件循环</a></h3>
<p>while是定义循环的一种方法：在条件为真时执行表达式。只要条件为<code>true</code>，代码将一遍又一遍的执行。条件通常使用外部变量或计数器实现。</p>
<pre><code class="language-Move">script {
    fun main() {

        let i = 0; // define counter

        // iterate while i &lt; 5
        // on every iteration increase i
        // when i is 5, condition fails and loop exits
        while (i &lt; 5) {
            i = i + 1;
        };
    }
}
</code></pre>
<p>需要指出的是，<code>while</code>表达式就像<code>if</code>表达式一样，也需要使用分号结束。while循环的通用语法是：</p>
<pre><code class="language-Move">while (&lt;布尔表达式&gt;) &lt;表达式&gt;;
</code></pre>
<p>与<code>if</code>表达式不同的是，<code>while</code>表达式没有返回值，因而也就不能像<code>if</code>那样把自己赋值给某变量。</p>
<h3><a class="header" href="#无法访问的代码" id="无法访问的代码">无法访问的代码</a></h3>
<p>安全是Move最显著的特性。出于安全考虑，Move规定所有变量必须被使用。并且出于同样的原因，Move禁止使用无法访问的代码。由于数字资产是可编程的，因此可以在代码中使用它们（我们将在Resource一章中对其进行介绍）。而将资产放置在无法访问的代码中可能会带来问题，并造成损失。</p>
<p>这就是为什么无法访问的代码如此重要的原因。</p>
<h3><a class="header" href="#无限循环" id="无限循环">无限循环</a></h3>
<p>Move提供了一种定义无限循环的方法，它没有条件判断，会一直执行。一旦执行该代码将消耗所有给定资源（gas），在大多数情况下，编译器也无法判断循环是否是无限的，也就无法阻止无限循环代码的发布。因此，使用无限循环时一定要注意安全，通常情况下建议使用<code>while</code>条件循环。</p>
<p>无限循环用关键字<code>loop</code>定义。</p>
<pre><code class="language-Move">script {
    fun main() {
        let i = 0;

        loop {
            i = i + 1;
        };

        // UNREACHABLE CODE
        let _ = i;
    }
}
</code></pre>
<p>下面的代码也是可以编译通过的:</p>
<pre><code class="language-Move">script {
    fun main() {
        let i = 0;

        loop {
            if (i == 1) { // i never changed
                break // this statement breaks loop
            }
        };

        // actually unreachable
        0x1::Debug::print&lt;u8&gt;(&amp;i);
    }
}
</code></pre>
<p>对于编译器而言，要了解循环是否真的是无限的，这是一项艰巨的任务，因此，就目前而言，只有开发者自己可以帮助自己发现循环错误，避免资产损失。</p>
<h3><a class="header" href="#通过-continue-和-break-控制循环" id="通过-continue-和-break-控制循环">通过 <code>continue</code> 和 <code>break</code> 控制循环</a></h3>
<p><code>continue</code>和<code>break</code>关键字，分别允许程序跳过一轮或中断循环，可以在两种类型的循环中同时使用它们。</p>
<p>例如，让我们在<code>loop</code>中添加两个条件，如果i是偶数，我们通过<code>continue</code>跳转到下一个迭代，而无需执行循环中<code>continue</code>之后的代码。当i等于5时，我们通过break停止迭代并退出循环。</p>
<pre><code class="language-Move">script {
    fun main() {
        let i = 0;

        loop {
            i = i + 1;

            if (i / 2 == 0) continue;
            if (i == 5) break;

            // assume we do something here
         };

        0x1::Debug::print&lt;u8&gt;(&amp;i);
    }
}
</code></pre>
<p>注意，如果break和continue是块中的最后一个关键字，则不能在其后加分号，因为后面的任何代码都不会被执行。请看这个例子：</p>
<pre><code class="language-Move">script {
    fun main() {
        let i = 0;

        loop {
            i = i + 1;

            if (i == 5) {
                break; // will result in compiler error. correct is `break` without semi
                       // Error: Unreachable code
            };

            // same with continue here: no semi, never;
            if (true) {
                continue
            };

            // however you can put semi like this, because continue and break here
            // are single expressions, hence they &quot;end their own scope&quot;
            if (true) continue;
            if (i == 5) break;
        }
    }
}
</code></pre>
<h3><a class="header" href="#有条件退出-abort" id="有条件退出-abort">有条件退出 <code>abort</code></a></h3>
<p>有时，当某些条件失败时，您需要中止程序的执行。对于这种情况，Move提供了有键字abort。</p>
<pre><code class="language-Move">script {
    fun main(a: u8) {

        if (a != 10) {
            abort 0;
        }

        // code here won't be executed if a != 10
        // transaction aborted
    }
}
</code></pre>
<p>关键字abort允许程序中止执行的同时报告错误代码。</p>
<h3><a class="header" href="#使用-assert-内置方法" id="使用-assert-内置方法">使用 <code>assert</code> 内置方法</a></h3>
<p>内置方法 <code>assert(&lt;condition&gt;, &lt;code&gt;)</code> 对 <code>abort</code>和条件进行了封装，你可以在代码中任何地方使用它。</p>
<pre><code class="language-Move">script {

    fun main(a: u8) {
        assert(a == 10, 0);

        // code here will be executed if (a == 10)
    }
}
</code></pre>
<p><code>assert()</code> 在不满足条件时将中止执行，在满足条件时将不执行任何操作。</p>
<h1><a class="header" href="#模块" id="模块">模块</a></h1>
<p>模块是发布在特定地址下的打包在一起的一组函数和结构体。前几章里，我们已经使用了脚本，脚本需要与已发布的模块或标准库一起运行，而标准库本身就是在0x1地址下发布的一组模块。</p>
<blockquote>
<p>模块在发布者的地址下发布。标准库在0x1地址下发布。</p>
</blockquote>
<blockquote>
<p>发布模块时，不会执行任何函数。要使用模块就得使用脚本。</p>
</blockquote>
<p>模块以<code>module</code>关键字开头，后面跟随模块名称和大括号，大括号中放置模块内容。</p>
<pre><code class="language-Move">module Math {

    // module contents

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }
}
</code></pre>
<blockquote>
<p>模块是发布代码供他人访问的唯一方法。新的类型和资源也只能在模块中定义。</p>
</blockquote>
<p>默认情况下，模块将在发布者的地址下进行编译和发布。但如果只是测试或开发，或者想要在模块中指定地址，请使用以下address <ADDR> {}语法：</p>
<pre><code class="language-Move">address 0x1 {
module Math {
    // module contents

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }
}
}
</code></pre>
<p><em>如示例所示：最佳实践是保持模块行不缩进</em></p>
<h2><a class="header" href="#导入" id="导入">导入</a></h2>
<p>Move在默认上下文中只能使用基本类型，也就是整型、布尔型和地址，可以执行的有意义或有用的操作也就是操作这些基本类型，或者基于基本类型定义新的类型。</p>
<p>除此之外还可以导入已发布的模块（或标准库）。</p>
<h3><a class="header" href="#直接导入" id="直接导入">直接导入</a></h3>
<p>可以直接在代码中按其地址使用模块：</p>
<pre><code class="language-Move">script {
    fun main(a: u8) {
        0x1::Debug::print(&amp;a);
    }
}
</code></pre>
<p>在此示例中，我们从地址0x1（标准库）导入了Debug模块，并使用了它的print方法。</p>
<h3><a class="header" href="#关键字-use" id="关键字-use">关键字 use</a></h3>
<p>要使代码更简洁（注意，0x1是特殊的地址，实际地址是很长的），可以使用关键字use：</p>
<pre><code class="language-Move">use &lt;Address&gt;::&lt;ModuleName&gt;;
</code></pre>
<p>这里 <code>&lt;Address&gt;</code> 是模块发布者的地址，<code>&lt;ModuleName&gt;</code> 是模块的名字。非常简单, 例如，我们可以像下面这样从<code>0x1</code>地址导入<code>Vector</code>模块。</p>
<pre><code class="language-Move">use 0x1::Vector;
</code></pre>
<h3><a class="header" href="#访问模块的内容" id="访问模块的内容">访问模块的内容</a></h3>
<p>要访问导入的模块的方法（或类型），需要使用::符号。非常简单，模块中定义的所有公开内容都可以通过双冒号进行访问。</p>
<pre><code class="language-Move">script {
    use 0x1::Vector;

    fun main() {
        // here we use method empty() of module Vector
        // the same way we'd access any other method of any other module
        let _ = Vector::empty&lt;u64&gt;();
    }
}
</code></pre>
<h3><a class="header" href="#在脚本中导入" id="在脚本中导入">在脚本中导入</a></h3>
<p>在脚本中，模块导入必须放在script {}块内：</p>
<pre><code class="language-Move">script {
    use 0x1::Vector;

    // in just the same way you can import any
    // other module(s). as many as you want!

    fun main() {
        let _ = Vector::empty&lt;u64&gt;();
    }
}
</code></pre>
<h3><a class="header" href="#在模块中导入" id="在模块中导入">在模块中导入</a></h3>
<p>在模块中导入模块必须在<code>module {}</code>块内进行:</p>
<pre><code class="language-Move">module Math {
    use 0x1::Vector;

    // the same way as in scripts
    // you are free to import any number of modules

    public fun empty_vec(): vector&lt;u64&gt; {
        Vector::empty&lt;u64&gt;();
    }
}
</code></pre>
<h3><a class="header" href="#成员导入" id="成员导入">成员导入</a></h3>
<p>导入语句还可以进一步被扩展，可以直接导入模块的成员:</p>
<pre><code class="language-Move">script {
    // single member import
    use 0x1::Signer::address_of;

    // multi member import (mind braces)
    use 0x1::Vector::{
        empty,
        push_back
    };

    fun main(acc: &amp;signer) {
        // use functions without module access
        let vec = empty&lt;u8&gt;();
        push_back(&amp;mut vec, 10);

        // same here
        let _ = address_of(acc);
    }
}
</code></pre>
<h3><a class="header" href="#使用-self-来同时导入模块和模块成员" id="使用-self-来同时导入模块和模块成员">使用 <code>Self</code> 来同时导入模块和模块成员</a></h3>
<p>导入语句还可以进一步扩展，通过使用 <code>Self</code> 来同时导入模块和模块成员，这里<code>Self</code>代表模块自己。</p>
<pre><code class="language-Move">script {
    use 0x1::Vector::{
        Self, // Self == Imported module
        empty
    };

    fun main() {
        // `empty` imported as `empty`
        let vec = empty&lt;u8&gt;();

        // Self means Vector
        Vector::push_back(&amp;mut vec, 10);
    }
}
</code></pre>
<h3><a class="header" href="#使用-use-as" id="使用-use-as">使用 use as</a></h3>
<p>当两个或多个模块具有相同的名称时，可以使用关键字as更改导入的模块的名称，这样可以在解决命名冲突的同时缩短代码长度。</p>
<p>语法：</p>
<pre><code class="language-Move">use &lt;Address&gt;::&lt;ModuleName&gt; as &lt;Alias&gt;;
</code></pre>
<p>在脚本中：</p>
<pre><code class="language-Move">script {
    use 0x1::Vector as V; // V now means Vector

    fun main() {
        V::empty&lt;u64&gt;();
    }
}
</code></pre>
<p>在模块中：</p>
<pre><code class="language-Move">module Math {
    use 0x1::Vector as Vec;

    fun length(&amp;v: vector&lt;u8&gt;): u64 {
        Vec::length(&amp;v)
    }
}
</code></pre>
<p>脚本中的例子：</p>
<pre><code class="language-Move">script {
    use 0x1::Vector::{
        Self as V,
        empty as empty_vec
    };

    fun main() {
        // `empty` imported as `empty_vec`
        let vec = empty_vec&lt;u8&gt;();

        // Self as V = Vector
        V::push_back(&amp;mut vec, 10);
    }
}
</code></pre>
<h1><a class="header" href="#常量" id="常量">常量</a></h1>
<p>Move支持<em>模块</em>或<em>脚本级</em>常量。常量一旦定义，就无法更改，所以可以使用常量为特定模块或脚本定义一些不变量，例如角色标识符等。</p>
<p>常量可以定义为基本类型（比如整数，布尔值和地址），也可以定义为数组。我们可以通过名称访问常量，但是要注意，常量对于定义它们的脚本/模块来说是本地的。</p>
<blockquote>
<p>我们无法从模块外部访问模块内部定义的常量</p>
</blockquote>
<pre><code class="language-Move">script {

    use 0x1::Debug;

    const RECEIVER : address = 0x999;

    fun main(account: &amp;signer) {
        Debug::print&lt;address&gt;(&amp;RECEIVER);

        // they can also be assigned to a variable

        let _ = RECEIVER;

        // but this code leads to compile error
        // RECEIVER = 0x800;
    }
}
</code></pre>
<p>一些用法:</p>
<pre><code class="language-Move">module M {

    const MAX : u64 = 100;

    // however you can pass constant outside using a function
    public fun get_max(): u64 {
        MAX
    }

    // or using
    public fun is_max(num: u64): bool {
        num == MAX
    }
}
</code></pre>
<p>使用常量时应该注意:</p>
<ol>
<li>一旦定义，它们是不可更改的。</li>
<li>它们在模块或脚本中是本地的，不能在外部使用。</li>
<li>可以将常量定义为一个表达式（带有花括号），但是此表达式的语法非常有限。</li>
</ol>
<h3><a class="header" href="#进一步阅读-1" id="进一步阅读-1">进一步阅读</a></h3>
<ul>
<li><a href="https://github.com/diem/diem/pull/4653">PR with constant syntax</a></li>
</ul>
<h1><a class="header" href="#函数" id="函数">函数</a></h1>
<p>Move中代码的执行是通过调用函数实现的。函数以fun关键字开头，后跟函数名称，扩在括号中的参数和扩在花括号中的函数体。</p>
<pre><code class="language-Move">fun function_name(arg1: u64, arg2: bool): u64 {
    // function body
}
</code></pre>
<p>我们在前面的章节中已经看到过函数，现在我们来学习如何使用函数。</p>
<blockquote>
<p>注意：Move函数使用snake_case命名规则，也就是小写字母以及下划线作为单词分隔符。</p>
</blockquote>
<h2><a class="header" href="#脚本中的函数" id="脚本中的函数">脚本中的函数</a></h2>
<p>脚本块只能包含一个被视为main的函数。它作为交易被执行，可以有参数，但是没有返回值。它可以操作其它已经发布的模块中的函数。</p>
<p>这里有一个简单的例子，用来检查地址是否存在：</p>
<pre><code class="language-Move">script {
    use 0x1::Account;

    fun main(addr: address) {
        assert(Account::exists(addr), 1);
    }
}
</code></pre>
<p>脚本中的函数可以带有参数，本例中它是address类型的参数addr。函数中操作了导入的模块Account。</p>
<blockquote>
<p>注意：由于只有一个函数，因此你可以按任意方式对它命名。一般情况下我们遵循惯用的编程概念将其称为main。</p>
</blockquote>
<h2><a class="header" href="#模块中的函数" id="模块中的函数">模块中的函数</a></h2>
<p>脚本中能使用的函数功能是相对有限的，函数的全部潜能只有在模块中才能展现。让我们再看一遍什么是模块：模块是一组发布了的函数和结构体（我们将在下一章中介绍结构体），它可以封装一项或多项功能。</p>
<p>在这一部分中，我们将创建一个简单的Math模块，它将为用户提供一组基本的数学函数和一些辅助方法。当然这里面大部分操作无需使用模块即可完成，但我们的目标是通过这个例子来理解函数。</p>
<pre><code class="language-Move">module Math {
    fun zero(): u8 {
        0
    }
}
</code></pre>
<p>第一步：我们定义一个Math模块，它有一个函数：zero()，该函数返回u8类型的值0。还记得我们之前介绍过的表达式吗？0之后没有分号，因为它是函数的返回值。是的，就像块表达式一样，函数与块非常相似。</p>
<h3><a class="header" href="#函数参数" id="函数参数">函数参数</a></h3>
<p>关于参数其实大家都已经很清楚了，但是我们还是稍微啰嗦一下，函数可以根据需要接受任意多个参数（传递给函数的值）。就像Move中的其他任何变量一样，每个参数都有两个属性：参数名，也就是参数在函数体内的名称，以及参数类型。</p>
<p>像作用域中定义的任何其他变量一样，函数参数仅存在于函数体内。当函数块结束时，参数也会消亡。</p>
<pre><code class="language-Move">module Math {

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }

    fun zero(): u8 {
        0
    }
}
</code></pre>
<p>大家发现有什么不一样了么？Math模块新增了sum(a,b)函数，该函数将两个u64值相加并作为u64结果返回。</p>
<p>关于参数的一些语法规则：</p>
<ol>
<li>参数必须具有类型，并且必须用逗号分隔</li>
<li>函数返回值放在括号后，并且必须在冒号后面</li>
</ol>
<p>下面我们如何在脚本中使用此函数呢？通过&quot;导入&quot;！</p>
<pre><code class="language-Move">script {
    use 0x1::Math;  // used 0x1 here; could be your address
    use 0x1::Debug; // this one will be covered later!

    fun main(first_num: u64, second_num: u64) {

        // variables names don't have to match the function's ones
        let sum = Math::sum(first_num, second_num);

        Debug::print&lt;u64&gt;(&amp;sum);
    }
}
</code></pre>
<h3><a class="header" href="#关键字-return" id="关键字-return">关键字 <code>return</code></a></h3>
<p>Keyword <code>return</code> allows you to stop function execution and return value. It is supposed to be used with <code>if</code> condition, as that is the only way to make conditional switch in control flow.
关键字return允许函数停止执行并返回结果。它可以与if条件一起使用，这样可以根据条件返回不同结果。</p>
<pre><code class="language-Move">module M {

    public fun conditional_return(a: u8): bool {
        if (a == 10) {
            return true // semi is not put!
        };

        if (a &lt; 10) {
            true
        } else {
            false
        }
    }
}
</code></pre>
<h3><a class="header" href="#多个返回值" id="多个返回值">多个返回值</a></h3>
<p>在前面的示例中，我们尝试了没有返回值或返回单个值的函数。但是，要想返回任何类型的多个值应该怎么办呢？好的，让我们继续往下看！</p>
<p>要指定多个返回值，需要使用括号：</p>
<pre><code class="language-Move">module Math {

    // ...

    public fun max(a: u8, b: u8): (u8, bool) {
        if (a &gt; b) {
            (a, false)
        } else if (a &lt; b) {
            (b, false)
        } else {
            (a, true)
        }
    }
}
</code></pre>
<p>该函数有两个参数：a和b，并返回两个值：第一个是两个输入参数中的较大的值，第二个是布尔类型，表示输入的参数是否相等。请仔细看一下语法，我们没有指定单个返回值，而是添加了括号并在其中列出了返回值类型。</p>
<p>现在让我们看看如何在另一个脚本中使用该函数的返回值。</p>
<pre><code class="language-Move">script {
    use 0x1::Debug;
    use 0x1::Math;

    fun main(a: u8, b: u8)  {
        let (max, is_equal) = Math::max(99, 100);

        assert(is_equal, 1)

        Debug::print&lt;u8&gt;(&amp;max);
    }
}
</code></pre>
<p>上面例子中，我们解构了一个二元组，用函数max的返回值创建了两个新变量。返回值的顺序保持不变，变量max用来存储u8类型的最大值，而is_equal用来存储bool类型。</p>
<p>返回值数量并没有限制，你可以根据需要决定元组的元素个数。下一章，我们还会介绍返回复杂数据的另一种方法，那就是结构体。</p>
<h3><a class="header" href="#函数可见性" id="函数可见性">函数可见性</a></h3>
<p>定义模块时，你可能希望其他开发人员可以访问某些函数，而某些函数则保持隐藏状态。这正是函数可见性修饰符发挥作用的时候。</p>
<p>默认情况下，模块中定义的每个函数都是私有的，无法在其它模块或脚本中访问。可能你已经注意到了，我们在Math模块中定义的某些函数前有关键字public：</p>
<pre><code class="language-Move">module Math {

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }

    fun zero(): u8 {
        0
    }
}
</code></pre>
<p>例子中Math模块被其它模块导入后，sum()函数可以从外部访问，但是zero()不能被访问，因为默认情况下它是私有的。</p>
<blockquote>
<p>关键字public将更改函数的默认可见性并使其公开，即可以从外部访问。</p>
</blockquote>
<p>基本上，如果不将sum()函数设为public，从外部访问是不可能的：</p>
<blockquote>
<p>Keyword <code>public</code> changes function's default <em>private</em> visibility and makes it <em>public</em> - i.e. accessible from outside.</p>
</blockquote>
<pre><code class="language-Move">script {
    use 0x1::Math;

    fun main() {
        Math::sum(10, 100); // won't compile!
    }
}
</code></pre>
<h3><a class="header" href="#访问私有函数" id="访问私有函数">访问私有函数</a></h3>
<p>如果根本无法访问，那么私有函数就没有任何意义了。调用public函数的同时，可以用私有函数来执行一些内部工作。</p>
<blockquote>
<p>私有函数只能在定义它们的模块中访问。</p>
</blockquote>
<p>那么如何访问同一模块中的函数？通过像导入一样简单地调用此函数！</p>
<p>There would not be any sense in making private functions if they could not be accessed at all. Private functions exist to do some <em>internal</em> work when public functions are called.</p>
<blockquote>
<p>Private functions can only be accessed in the module where they're defined.</p>
</blockquote>
<pre><code class="language-Move">module Math {

    public fun is_zero(a: u8): bool {
        a == zero()
    }

    fun zero(): u8 {
        0
    }
}
</code></pre>
<p>一个模块中定义的任何函数都可以被同一模块中的任何函数访问，无论它们的可见性修饰符是什么。这样，私有函数仍然可以在内部调用，而且不会暴露某些私有操作到模块外。</p>
<h3><a class="header" href="#本地方法" id="本地方法">本地方法</a></h3>
<p>有一种特殊的函数叫本地方法。本地方法实现的功能超出了Move的能力，它可以提供了额外的功能。本地方法由VM本身定义，并且在不同的VM实现中可能会有所不同。这意味着它们没有用Move语法实现，没有函数体，直接以分号结尾。关键字native用于标记本地函数，它和函数可见性修饰符不冲突，native和public可以同时使用。</p>
<p>这是Diem标准库中的示例。</p>
<pre><code class="language-Move">module Signer {

    native public fun borrow_address(s: &amp;signer): &amp;address;

    // ... some other functions ...
}
</code></pre>
<h1><a class="header" href="#结构体" id="结构体">结构体</a></h1>
<p>结构体是自定义类型，它可以包含复杂数据，也可以不包含任何数据。可以将其描述为简单的&quot;键-值&quot;存储，其中key是属性的名称，而value是存储的内容。结构体使用关键字struct定义。</p>
<blockquote>
<p>结构体（和Resource结构体）是在Move中创建自定义类型的唯一方法。</p>
</blockquote>
<p>定义</p>
<h3><a class="header" href="#定义" id="定义">定义</a></h3>
<p>结构体只能在模块内部定义。</p>
<pre><code class="language-Move">module M {

    // struct can be without fields
    // but it is a new type
    struct Empty {}

    struct MyStruct {
        field1: address,
        field2: bool,
        field3: Empty
    }

    struct Example {
        field1: u8,
        field2: address,
        field3: u64,
        field4: bool,
        field5: bool,

        // you can use another struct as type
        field6: MyStruct
    }
}
</code></pre>
<p><em>一个结构体中的字段最多可以有65535个。</em>.</p>
<p>每个定义的结构体都会成为新的类型。可以通过其模块访问此类型：</p>
<pre><code>M::MyStruct;
// or
M::Example;
</code></pre>
<h3><a class="header" href="#定义递归结构体" id="定义递归结构体">定义递归结构体</a></h3>
<blockquote>
<p><em>定义递归结构体</em> 是不允许的。</p>
</blockquote>
<p>Move允许使用其它结构作为成员，但不能递归使用相同的结构体。Move编译器会检查递归定义，不允许下面这样的代码：</p>
<pre><code class="language-Move">module M {
    struct MyStruct {

        // WON'T COMPILE
        field: MyStruct
    }
}
</code></pre>
<h3><a class="header" href="#创建结构体实例" id="创建结构体实例">创建结构体实例</a></h3>
<blockquote>
<p>要使用某类型，需要先创建其实例。</p>
</blockquote>
<p>可以用结构体的定义来创建实例，不同的是传入具体的值而不是类型。</p>
<pre><code class="language-Move">module M {
    struct Country {
        id: u8,
        population: u64
    }

    // Contry is a return type of this function!
    public fun new_country(c_id: u8, c_population: u64): Country {
        // structure creation is an expression
        let country = Country {
            id: c_id,
            population: c_population
        };

        country
    }
}
</code></pre>
<p>还可以通过传递与struct的字段名匹配的变量名来简化创建新实例的代码。下面的new_country()函数中使用了这个简化方法：</p>
<pre><code class="language-Move">// ...
public fun new_country(id: u8, population: u64): Country {
    // id matches id: u8 field
    // population matches population field
    Country {
        id,
        population
    }

    // or even in one line: Country { id, population }
}
</code></pre>
<p>要创建一个空结构（没有字段），只需使用花括号：</p>
<pre><code class="language-Move">public fun empty(): Empty {
    Empty {}
}
</code></pre>
<h3><a class="header" href="#访问结构体成员字段" id="访问结构体成员字段">访问结构体成员字段</a></h3>
<p>如果我们没有办法访问结构体的字段，那么它们几乎是无用的。</p>
<blockquote>
<p>只有在模块内可以访问其结构体的字段。在模块之外，该结构体字段是私有的。</p>
</blockquote>
<p>结构字段仅在其模块内部可见。在此模块之外（在脚本或其他模块中），它只是一种类型。要访问结构的字段，请使用&quot;.&quot;符号：</p>
<pre><code class="language-Move">// ...
public fun get_country_population(country: Country): u64 {
    country.population // &lt;struct&gt;.&lt;property&gt;
}
</code></pre>
<p>如果在同一模块中定义了嵌套结构类型，则可以用类似的方式对其进行访问，通常可以将其描述为：</p>
<pre><code class="language-Move">&lt;struct&gt;.&lt;field&gt;
// and field can be another struct so
&lt;struct&gt;.&lt;field&gt;.&lt;nested_struct_field&gt;...
</code></pre>
<h3><a class="header" href="#为结构体字段实现getter方法" id="为结构体字段实现getter方法">为结构体字段实现getter方法</a></h3>
<p>为了使结构体字段在外部可读，需要实现一些方法，这些方法将读取这些字段并将它们作为返回值传递。通常，getter方法的调用方式与struct的字段相同，但是如果你的模块定义了多个结构，则getter方法可能会带来不便。</p>
<pre><code class="language-Move">module Country {

    struct Country {
        id: u8,
        population: u64
    }

    public fun new_country(id: u8, population: u64): Country {
        Country {
            id, population
        }
    }

    // don't forget to make these methods public!
    public fun id(country: &amp;Country): u8 {
        country.id
    }

    // don't mind ampersand here for now. you'll learn why it's put here
    // in references chapter in next part of the book
    public fun population(country: &amp;Country): u64 {
        country.population
    }
}
</code></pre>
<p>通过getter方法，我们允许模块用户访问结构体的字段：</p>
<pre><code class="language-Move">script {
    use {{sender}}::Country as C;
    use 0x1::Debug;

    fun main() {
        // variable here is of type C::Country
        let country = C::new_country(1, 10000000);

        Debug::print&lt;u8&gt;(
            &amp;C::id(&amp;country)
        ); // print id

        Debug::print&lt;u64&gt;(
            &amp;C::population(&amp;country)
        );

        // however this is impossible and will lead to compile error
        // let id = country.id;
        // let population = country.population.
    }
}
</code></pre>
<h3><a class="header" href="#回收结构体" id="回收结构体">回收结构体</a></h3>
<p>解构、或者说销毁结构体需要使用语法 <code>let &lt;STRUCT DEF&gt; = &lt;STRUCT&gt;</code>：</p>
<pre><code class="language-Move">module Country {

    // ...

    // we'll return values of this struct outside
    public fun destroy(country: Country): (u8, u64) {

        // variables must match struct fields
        // all struct fields must be specified
        let Country { id, population } = country;

        // after destruction country is dropped
        // but its fields are now variables and
        // can be used
        (id, population)
    }
}
</code></pre>
<p>请注意，Move中禁止使用未被使用的变量，有时你可能需要在不使用其字段的情况下销毁该结构体。对于未使用的结构体字段，请使用下划线&quot;_&quot;：</p>
<pre><code class="language-Move">module Country {
    // ...

    public fun destroy(country: Country) {

        // this way you destroy struct and don't create unused variables
        let Country { id: _, population: _ } = country;

        // or take only id and don't init `population` variable
        // let Country { id, population: _ } = country;
    }
}
</code></pre>
<p>销毁结构体并不是必需的，但是，我们即将介绍的Resource结构体则必需被销毁。</p>
<h1><a class="header" href="#进阶主题" id="进阶主题">进阶主题</a></h1>
<p>在本节中，我们来学习一些在Move中广泛使用的编程概念：所有权，泛型和向量。它们为Move语言的关键功能 Resource 打下了坚实的基础。</p>
<h1><a class="header" href="#所有权和引用" id="所有权和引用">所有权和引用</a></h1>
<p>Move VM实现了类似Rust的所有权系统。关于所有权的详细描述，可以参考<a href="https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html">Rust Book</a> 。</p>
<p>Rust语法不同于Move，某些示例可能不容易理解，但还是建议大家先阅读一下Rust Book中的所有权一章。当然，关于所有权的关键点本书也会逐一介绍。</p>
<blockquote>
<p>每个变量只有一个所有者作用域。当所有者作用域结束时，变量将被删除。</p>
</blockquote>
<p>变量的寿命与它的作用域一样长，我们曾经在表达式一章中看到过这种行为，大家还有没有印象？现在是了解其内部机制的绝佳时机了。</p>
<p>所有者是<em>拥有</em>某变量的作用域。变量可以在作用域内定义（例如，在脚本中使用关键字let），也可以作为参数传递给作用域。由于Move中唯一的作用域是函数的作用域，所以除了这两种方法，没有其它方法可以将变量放入作用域。</p>
<p>每个变量只有一个所有者，这意味着当把变量作为参数传递给函数时，该函数将成为<em>新所有者</em>，并且第一个函数不再<em>拥有</em>该变量。或者你可以说，第二个函数接管了变量的<em>所有权</em>。</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        // Module::T is a struct
        let a : Module::T = Module::create(10);

        // here variable `a` leaves scope of `main` function
        // and is being put into new scope of `M::value` function
        M::value(a);

        // variable a no longer exists in this scope
        // this code won't compile
        M::value(a);
    }
}
</code></pre>
<p>让我们看一下将变量传递给value()函数时，内部发生的情况：</p>
<pre><code class="language-Move">module M {
    // create_fun skipped
    struct T { value: u8 }

    public fun create(value: u8): T {
        T { value }
    }

    // variable t of type M::T passed
    // `value()` function takes ownership
    public fun value(t: T): u8 {
        // we can use t as variable
        t.value
    }
    // function scope ends, t dropped, only u8 result returned
    // t no longer exists
}
</code></pre>
<p>我们可以看到，当函数value()结束时，t将不复存在，返回的只是一个u8类型的值。如何让t仍然可用呢？当然，一种快速的解决方案是返回一个元组，该元组包含原始变量和其它结果，但是Move还有一个更好的解决方案。</p>
<h2><a class="header" href="#move-和-copy" id="move-和-copy">move 和 copy</a></h2>
<p>首先，我们了解一下Move VM的工作原理，以及将值传递给函数时会发生什么。Move VM里有两个字节码指令：<em>MoveLoc</em>和<em>CopyLoc</em>，反映到Move语言层面，它们分别对应关键字<code>move</code>和<code>copy</code>。</p>
<p>将变量传递到另一个函数时，MoveLoc指令被使用，它会被<em>move</em>。我们可以像下面这样显式使用<em>move</em>关键字：</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a : Module::T = Module::create(10);

        M::value(move a); // variable a is moved

        // local a is dropped
    }
}
</code></pre>
<p>这段代码是没有问题的，但是我们平常并不需要显示使用<em>move</em>，缺省a会被<em>move</em>。那么<em>copy</em>又是怎么回事呢？</p>
<h3><a class="header" href="#关键字-copy" id="关键字-copy">关键字 <code>copy</code></a></h3>
<p>如果想保留变量的值，同时仅将值的副本传递给某函数，则可以使用关键字<code>copy</code>。</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a : Module::T = Module::create(10);

        // we use keyword copy to clone structure
        // can be used as `let a_copy = copy a`
        M::value(copy a);
        M::value(a); // won't fail, a is still here
    }
}
</code></pre>
<p>上例中，我们第一次调用函数value()时，将变量a的副本传递给函数，并保留a在本地作用域中，以便第二次调用函数时再次使用它。</p>
<p>使用<em>copy</em>后，我们实际上复制了变量值从而增加了程序占用内存的大小。但是如果复制数据数据量比较大，它的内存消耗可能会很高。这里要注意了，在区块链中，交易执行时占用的内存资源是消耗交易费的，每个字节都会影响交易执行价格。因此不加限制的使用 copy 会浪费很多钱。</p>
<p>现在，是时候学习<code>引用</code>了，它可以帮助我们避免不必要的<code>copy</code>从而节省一些钱。</p>
<h2><a class="header" href="#引用" id="引用">引用</a></h2>
<p>许多编程语言都支持<code>引用</code>。<em>引用</em>是指向变量（通常是内存中的某个片段）的链接，你可以将其传递到程序的其他部分，而无需移动变量值。</p>
<blockquote>
<p>引用（标记为＆）使我们可以引用值而无需拥有所有权。</p>
</blockquote>
<p>我们修改一下上面的示例，看看如何使用引用。</p>
<pre><code class="language-Move">module M {
    struct T { value: u8 }
    // ...
    // ...
    // instead of passing a value, we'll pass a reference
    public fun value(t: &amp;T): u8 {
        t.value
    }
}
</code></pre>
<p>我们在参数类型T前添加了＆符号，这样就可以将参数类型T转换成了T的引用&amp;T。</p>
<blockquote>
<p>Move支持两种类型的引用：不可变引用&amp;（例如&amp;T）和可变引用 &amp;mut（例如&amp;mut T）。</p>
</blockquote>
<p>不可变的引用允许我们在不更改值的情况下读取值。可变引用赋予我们读取和更改值的能力。</p>
<pre><code class="language-Move">module M {
    struct T { value: u8 }

    // returned value is of non-reference type
    public fun create(value: u8): T {
        T { value }
    }

    // immutable references allow reading
    public fun value(t: &amp;T): u8 {
        t.value
    }

    // mutable references allow reading and changing the value
    public fun change(t: &amp;mut T, value: u8) {
        t.value = value;
    }
}
</code></pre>
<p>现在，让我们看看如何使用升级后的模块M。</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let t = M::create(10);

        // create a reference directly
        M::change(&amp;mut t, 20);

        // or write reference to a variable
        let mut_ref_t = &amp;mut t;

        M::change(mut_ref_t, 100);

        // same with immutable ref
        let value = M::value(&amp;t);

        // this method also takes only references
        // printed value will be 100
        0x1::Debug::print&lt;u8&gt;(&amp;value);
    }
}
</code></pre>
<blockquote>
<p>使用不可变引用（＆）从结构体读取数据，使用可变引用（＆mut）修改它们。通过使用适当类型的引用，我们可以更加安全的读取模块，因为它能告诉代码的阅读者，该变量是否会被修改。</p>
</blockquote>
<h3><a class="header" href="#borrow-检查" id="borrow-检查">Borrow 检查</a></h3>
<p>Move通过&quot;Borrow 检查&quot;来控制程序中&quot;引用&quot;的使用，这样有助于防止意外出错。为了理解这一点，我们看一个例子。</p>
<pre><code class="language-Move">module Borrow {

    struct B { value: u64 }
    struct A { b: B }

    // create A with inner B
    public fun create(value: u64): A {
        A { b: B { value } }
    }

    // give a mutable reference to inner B
    public fun ref_from_mut_a(a: &amp;mut A): &amp;mut B {
        &amp;mut a.b
    }

    // change B
    public fun change_b(b: &amp;mut B, value: u64) {
        b.value = value;
    }
}
</code></pre>
<pre><code class="language-Move">script {
    use {{sender}}::Borrow;

    fun main() {
        // create a struct A { b: B { value: u64 } }
        let a = Borrow::create(0);

        // get mutable reference to B from mut A
        let mut_a = &amp;mut a;
        let mut_b = Borrow::ref_from_mut_a(mut_a);

        // change B
        Borrow::change_b(mut_b, 100000);

        // get another mutable reference from A
        let _ = Borrow::ref_from_mut_a(mut_a);
    }
}
</code></pre>
<p>上面代码可以成功编译运行，不会报错。这里究竟发生了什么呢？首先，我们使用A的可变引用（&amp;mut A）来获取对其内部struct B的可变引用（&amp;mut B）。然后我们改变B。然后可以再次通过&amp;mut A获取对B的可变引用。</p>
<p>但是，如果我们交换最后两个表达式，即首先尝试创建新的&amp;mut A，而&amp;mut B仍然存在，会出现什么情况呢？</p>
<pre><code class="language-Move">let mut_a = &amp;mut a;
let mut_b = Borrow::ref_from_mut_a(mut_a);

let _ = Borrow::ref_from_mut_a(mut_a);

Borrow::change_b(mut_b, 100000);
</code></pre>
<p>编辑器将会报错：</p>
<pre><code class="language-Move">    ┌── /scripts/script.move:10:17 ───
    │
 10 │         let _ = Borrow::ref_from_mut_a(mut_a);
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid usage of reference as function argument. Cannot transfer a mutable reference that is being borrowed
    ·
  8 │         let mut_b = Borrow::ref_from_mut_a(mut_a);
    │                     ----------------------------- It is still being mutably borrowed by this reference
    │
</code></pre>
<p>该代码不会编译成功。为什么？因为&amp;mut A已经被&amp;mut B借用。如果我们再将其作为参数传递，那么我们将陷入一种奇怪的情况，A可以被更改，但A同时又被引用。而mut_b应该指向何处呢？</p>
<p>我们得出一些结论：</p>
<ol>
<li>编译器通过所谓的&quot;借用检查&quot;（最初是Rust语言的概念）来防止上面这些错误。编译器通过建立&quot;借用图&quot;，不允许被借用的值被move。这就是Move在区块链中如此安全的原因之一。</li>
<li>可以从引用创建新的引用，老得引用将被新引用&quot;借用&quot;。可变引用可以创建可变或者不可变引用，而不可变引用只能创建不可变引用。</li>
<li>当一个值被引用时，就无法move它了，因为其它值对它有依赖。</li>
</ol>
<h3><a class="header" href="#取值运算" id="取值运算">取值运算</a></h3>
<p>可以通过<code>取值</code>运算<code>*</code>来获取引用所指向的值。</p>
<blockquote>
<p>取值运算实际上是产生了一个副本。</p>
</blockquote>
<pre><code class="language-Move">module M {
    struct T {}

    // value t here is of reference type
    public fun deref(t: &amp;T): T {
        *t
    }
}
</code></pre>
<blockquote>
<p>取值运算不会将原始值move到当前作用域，实际上只是生成了一个副本。</p>
</blockquote>
<p>有一个技巧用来复制一个结构体的字段：就是使用<code>*&amp;</code>，引用并取值。我们来看一个例子：</p>
<pre><code class="language-Move">module M {
    struct H {}
    struct T { inner: H }

    // ...

    // we can do it even from immutable reference!
    public fun copy_inner(t: &amp;T): H {
        *&amp;t.inner
    }
}
</code></pre>
<p>通过使用*&amp;（编译器会建议这样做），我们复制了结构体的内部值。</p>
<h3><a class="header" href="#引用基本类型" id="引用基本类型">引用基本类型</a></h3>
<p>基本类型非常简单，它们不需要作为引用传递，缺省会被复制。当基本类型的值被传给函数时，相当于使用了<code>copy</code>关键字，传递进函数的是它们的副本。当然你可以使用<code>move</code>关键字强制不产生副本，但是由于基本类型的大小很小，复制它们其实开销很小，甚至比通过引用或者move传递它们开销更小。</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a = 10;
        M::do_smth(a);
        let _ = a;
    }
}
</code></pre>
<p>也就是说，即使我们没有将<code>a</code>作为引用传递，该脚本也会编译。我们也无需添加<code>copy</code>，因为VM已经帮组我们添加了。</p>
<h1><a class="header" href="#了解泛型" id="了解泛型">了解泛型</a></h1>
<p>泛型对于Move语言是必不可少的，它使得Move语言在区块链世界中如此独特，它是Move灵活性的重要来源。</p>
<p>首先，让我来引用<a href="https://doc.rust-lang.org/stable/book/ch10-00-generics.html">Rust Book</a> 对于泛型得定义：<em>泛型是具体类型或其他属性的抽象替代品</em>。实际上，泛型允许我们只编写单个函数，而该函数可以应用于任何类型。这种函数也被称为模板，一个可以应用于任何类型的模板处理程序。</p>
<p>Move中泛型可以应用于struct，function和resource的定义中。</p>
<h3><a class="header" href="#结构体中的泛型" id="结构体中的泛型">结构体中的泛型</a></h3>
<p>首先，我们将创建一个可容纳<code>u64</code>整型的 Box ：</p>
<pre><code class="language-Move">module Storage {
    struct Box {
        value: u64
    }
}
</code></pre>
<p>这个 Box 只能包含<code>u64</code>类型的值，这一点是非常清楚的。但是，如果我们想为<code>u8</code>类型或 bool类型创建相同的 Box 该怎么办呢？分别创建<code>u8</code>类型的 Box1 和<code>bool</code>型 Box2 吗？答案是否定的，因为可以使用泛型。</p>
<pre><code class="language-Move">module Storage {
    struct Box&lt;T&gt; {
        value: T
    }
}
</code></pre>
<p>我们在结构体名字的后面增加<code>&lt;T&gt;</code>。尖括号<code>&lt;..&gt;</code>里面用来定义泛型，这里<code>T</code>就是我们在结构体中模板化的类型。在结构体中，我们已经将<code>T</code>用作常规类型。类型T实际并不存在，它只是任何类型的占位符。</p>
<h3><a class="header" href="#函数中的泛型" id="函数中的泛型">函数中的泛型</a></h3>
<p>现在让我们为上面的结构体创建一个构造函数，该构造函数将首先使用u64类型。</p>
<pre><code class="language-Move">module Storage {
    struct Box&lt;T&gt; {
        value: T
    }

    // type u64 is put into angle brackets meaning
    // that we're using Box with type u64
    public fun create_box(value: u64): Box&lt;u64&gt; {
        Box&lt;u64&gt;{ value }
    }
}
</code></pre>
<p>带有泛型的结构体的创建稍微有些复杂，因为它们需要指定类型参数，需要把常规结构体 Box 变为 Box<u64>。Move没有任何限制什么类型可以被放进尖括号中。但是为了让<code>create_box</code>方法更通用，有没有更简单的方法？有的，在函数中使用泛型！</p>
<pre><code class="language-Move">module Storage {
    // ...
    public fun create_box&lt;T&gt;(value: T): Box&lt;T&gt; {
        Box&lt;T&gt; { value }
    }

    // we'll get to this a bit later, trust me
    public fun value&lt;T: copyable&gt;(box: &amp;Box&lt;T&gt;): T {
        *&amp;box.value
    }
}
</code></pre>
<h3><a class="header" href="#函数调用中使用泛型" id="函数调用中使用泛型">函数调用中使用泛型</a></h3>
<p>上例中在定义函数时，我们像结构体一样在函数名之后添加了尖括号。如何使用它呢？就是在函数调用中指定类型。</p>
<pre><code class="language-Move">script {
    use {{sender}}::Storage;
    use 0x1::Debug;

    fun main() {
        // value will be of type Storage::Box&lt;bool&gt;
        let bool_box = Storage::create_box&lt;bool&gt;(true);
        let bool_val = Storage::value(&amp;bool_box);

        assert(bool_val, 0);

        // we can do the same with integer
        let u64_box = Storage::create_box&lt;u64&gt;(1000000);
        let _ = Storage::value(&amp;u64_box);

        // let's do the same with another box!
        let u64_box_in_box = Storage::create_box&lt;Storage::Box&lt;u64&gt;&gt;(u64_box);

        // accessing value of this box in box will be tricky :)
        // Box&lt;u64&gt; is a type and Box&lt;Box&lt;u64&gt;&gt; is also a type
        let value: u64 = Storage::value&lt;u64&gt;(
            &amp;Storage::value&lt;Storage::Box&lt;u64&gt;&gt;( // Box&lt;u64&gt; type
                &amp;u64_box_in_box // Box&lt;Box&lt;u64&gt;&gt; type
            )
        );

        // you've already seed Debug::print&lt;T&gt; method
        // which also uses generics to print any type
        Debug::print&lt;u64&gt;(&amp;value);
    }
}
</code></pre>
<p>这里我们用3种类型使用了 Box：<code>bool</code>, <code>u64</code> 和 <code>Box&lt;u64&gt;</code>。最后一个看起来有些复杂，但是一旦你习惯了，并且理解了泛型是如何工作的，它成为你日常工作的好帮手。</p>
<p>继续下一步之前，让我们做一个简单的回顾。我们通过将泛型添加到<code>Box</code>结构体中，使<code>Box</code>变得抽象了。与 Box 能提供的功能相比，它的定义相当简单。现在，我们可以使用任何类型创建<code>Box</code>，u64 或 address，甚至另一个 Box 或另一个结构体。</p>
<h3><a class="header" href="#泛型中包含多个类型" id="泛型中包含多个类型">泛型中包含多个类型</a></h3>
<p>我们也可以在泛型中使用多个类型，像使用单个类型一样，把多个类型放在尖括号中，并用逗号分隔。我们来试着添加一个新类型<code>Shelf</code>，它将容纳两个不同类型的<code>Box</code>。</p>
<pre><code class="language-Move">module Storage {

    struct Box&lt;T&gt; {
        value: T
    }

    struct Shelf&lt;T1, T2&gt; {
        box_1: Box&lt;T1&gt;,
        box_2: Box&lt;T2&gt;
    }

    public fun create_shelf&lt;Type1, Type2&gt;(
        box_1: Box&lt;Type1&gt;,
        box_2: Box&lt;Type2&gt;
    ): Shelf&lt;Type1, Type2&gt; {
        Shelf {
            box_1,
            box_2
        }
    }
}
</code></pre>
<p><code>Shelf</code>的类型参数需要与结构体字段定义中的类型顺序相匹配，而泛型中的类型参数的名称则无需相同，选择合适的名称即可。正是因为每种类型参数仅仅在其作用域范围内有效，所以无需使用相同的名字。</p>
<p>多类型泛型的使用与单类型泛型相同：</p>
<pre><code class="language-Move">script {
    use {{sender}}::Storage;

    fun main() {
        let b1 = Storage::create_box&lt;u64&gt;(100);
        let b2 = Storage::create_box&lt;u64&gt;(200);

        // you can use any types - so same ones are also valid
        let _ = Storage::create_shelf&lt;u64, u64&gt;(b1, b2);
    }
}
</code></pre>
<p>*你可以在函数或结构体定义中最多使用 18,446,744,073,709,551,615 (u64 最大值) 个泛型。你绝对不会达到此限制，因此可以随意使用。</p>
<h3><a class="header" href="#未使用的类型参数" id="未使用的类型参数">未使用的类型参数</a></h3>
<p>并非泛型中指定的每种类型参数都必须被使用。看这个例子：</p>
<pre><code class="language-Move">module Storage {

    // these two types will be used to mark
    // where box will be sent when it's taken from shelf
    struct Abroad {}
    struct Local {}

    // modified Box will have target property
    struct Box&lt;T, Destination&gt; {
        value: T
    }

    public fun create_box&lt;T, Dest&gt;(value: T): Box&lt;T, Dest&gt; {
        Box { value }
    }
}
</code></pre>
<p>在脚本中可以使用 :</p>
<pre><code class="language-Move">
script {
    use {{sender}}::Storage;

    fun main() {
        // value will be of type Storage::Box&lt;bool&gt;
        let _ = Storage::create_box&lt;bool, Storage::Abroad&gt;(true);
        let _ = Storage::create_box&lt;u64, Storage::Abroad&gt;(1000);

        let _ = Storage::create_box&lt;u128, Storage::Local&gt;(1000);
        let _ = Storage::create_box&lt;address, Storage::Local&gt;(0x1);

        // or even u64 destination!
        let _ = Storage::create_box&lt;address, u64&gt;(0x1);
    }
}
</code></pre>
<p>在这里，我们使用泛型标记类型，但实际上并没有真正使用它。当你了解resources后，就会知道为什么这种定义很重要。目前，就当这只是使用泛型的一种方法。</p>
<h3><a class="header" href="#kind-和-copyable" id="kind-和-copyable">Kind 和 copyable</a></h3>
<p>在<a href="advanced-topics//advanced-topics/ownership-and-references.html">所有权</a>一章中，我们了解了VM中的复制和移动操作。Move中所有的值都可以移动，但是并非每个值都可以复制。在即将学习的<code>Resource</code>一章中，我们将了解哪些值不可复制。但是在学习它之前，让我们先来了解一下<code>Kind</code>是什么。</p>
<p><code>Kind</code>可以用来限制传递给函数的泛型类型。<code>Kind</code>有两种：<code>copyable</code>和<code>resource</code>。</p>
<h3><a class="header" href="#copyable" id="copyable">Copyable</a></h3>
<p>Copyable（可复制的）<code>Kind</code>是这样一类类型：其值可以被复制。结构体，数组和基本类型是三大类可以用<code>Copyable</code>修饰的类型。</p>
<p>要了解为什么Move需要<code>Copyable</code>修饰符，请看以下示例：</p>
<pre><code class="language-Move">module M {
    public fun deref&lt;T&gt;(t: &amp;T): T {
        *t
    }
}
</code></pre>
<p>通过对引用使用<em>取值</em>操作，我们可以复制原始值并将其作为返回值返回。但是，如果我们在此示例中尝试使用使用<em>resource</em>，会出现什么情况？<em>resource</em>无法复制，预示着代码将会失败。当然编译器不会让我们编译通过，并且用于管理这种情况的<code>Kind</code>已经存在了，那就是<code>copyable</code>。</p>
<pre><code class="language-Move">module M {
    public fun deref&lt;T: copyable&gt;(t: &amp;T): T {
        *t
    }
}
</code></pre>
<p>我们在泛型定义中增加了<code>copyable</code>，现在typeT必须是可复制的。所以，现在的函数只接受结构体，数组和基本类型作为参数。编译器通过<em>copyable</em>修饰符对已使用类型的安全性进行检查，在此处传递不可复制的值是不可能的。</p>
<h3><a class="header" href="#resource" id="resource">Resource</a></h3>
<p>另一种 kind <code>resource</code> 用来限制参数类型只能是<code>Resource</code>，使用方法跟<code>copyable</code>类似。</p>
<pre><code class="language-Move">module M {
    public fun smth&lt;T: resource&gt;(t: &amp;T) {
        // do smth
    }
}
</code></pre>
<p>此处的示例仅用于展示语法，我们很快会接触到Resource，并学习<code>resource</code>修饰符的实际使用。</p>
<h1><a class="header" href="#用-vector-管理集合" id="用-vector-管理集合">用 Vector 管理集合</a></h1>
<p>我们已经非常熟悉结构体类型了，它使我们能够创建自己的类型并存储复杂数据。但是有时我们需要动态、可扩展和可管理的功能。为此，Move 提供了向量 Vector。</p>
<p>Vector 是用于存储数据集合的内置类型。集合的数据可以是任何类型（但仅一种）。Vector 功能实际上是由VM提供的，不是由Move语言提供的，使用它的唯一方法是使用标准库和 native 函数。</p>
<pre><code class="language-Move">script {
    use 0x1::Vector;

    fun main() {
        // use generics to create an emtpy vector
        let a = Vector::empty&lt;&amp;u8&gt;();
        let i = 0;

        // let's fill it with data
        while (i &lt; 10) {
            Vector::push_back(&amp;mut a, i);
            i = i + 1;
        }

        // now print vector length
        let a_len = Vector::length(&amp;a);
        0x1::Debug::print&lt;u64&gt;(&amp;a_len);

        // then remove 2 elements from it
        Vector::pop_back(&amp;mut a);
        Vector::pop_back(&amp;mut a);

        // and print length again
        let a_len = Vector::length(&amp;a);
        0x1::Debug::print&lt;u64&gt;(&amp;a_len);
    }
}
</code></pre>
<p>Vector 最多可以存储 18446744073709551615u64（u64最大值）个非引用类型的值。要了解它如何帮助我们管理大型数据，我们试着编写一个模块。</p>
<pre><code class="language-Move">module Shelf {

    use 0x1::Vector;

    struct Box&lt;T&gt; {
        value: T
    }

    struct Shelf&lt;T&gt; {
        boxes: vector&lt;Box&lt;T&gt;&gt;
    }

    public fun create_box&lt;T&gt;(value: T): Box&lt;T&gt; {
        Box { value }
    }

    public fun value&lt;T: copyable&gt;(box: &amp;Box&lt;T&gt;): T {
        *&amp;box.value
    }

    public fun create&lt;T&gt;(): Shelf&lt;T&gt; {
        Shelf {
            boxes: Vector::empty&lt;Box&lt;T&gt;&gt;()
        }
    }

    // box value is moved to the vector
    public fun put&lt;T&gt;(shelf: &amp;mut Shelf&lt;T&gt;, box: Box&lt;T&gt;) {
        Vector::push_back&lt;Box&lt;T&gt;&gt;(&amp;mut shelf.boxes, box);
    }

    public fun remove&lt;T&gt;(shelf: &amp;mut Shelf&lt;T&gt;): Box&lt;T&gt; {
        Vector::pop_back&lt;Box&lt;T&gt;&gt;(&amp;mut shelf.boxes)
    }

    public fun size&lt;T&gt;(shelf: &amp;Shelf&lt;T&gt;): u64 {
        Vector::length&lt;Box&lt;T&gt;&gt;(&amp;shelf.boxes)
    }
}
</code></pre>
<p>我们将创建一个 Shelf，为其提供几个 Box，并观察如何在模块中使用 vector：</p>
<pre><code class="language-Move">script {
    use {{sender}}::Shelf;

    fun main() {

        // create shelf and 2 boxes of type u64
        let shelf = Shelf::create&lt;u64&gt;();
        let box_1 = Shelf::create_box&lt;u64&gt;(99);
        let box_2 = Shelf::create_box&lt;u64&gt;(999);

        // put both boxes to shelf
        Shelf::put(&amp;mut shelf, box_1);
        Shelf::put(&amp;mut shelf, box_2);

        // prints size - 2
        0x1::Debug::print&lt;u64&gt;(&amp;Shelf::size&lt;u64&gt;(&amp;shelf));

        // then take one from shelf (last one pushed)
        let take_back = Shelf::remove(&amp;mut shelf);
        let value     = Shelf::value&lt;u64&gt;(&amp;take_back);

        // verify that the box we took back is one with 999
        assert(value == 999, 1);

        // and print size again - 1
        0x1::Debug::print&lt;u64&gt;(&amp;Shelf::size&lt;u64&gt;(&amp;shelf));
    }
}
</code></pre>
<p>向量非常强大，它使我们可以存储大量数据，并可以在索引的存储中使用它。</p>
<h3><a class="header" href="#内联-vector-定义的十六进制数组和字符串" id="内联-vector-定义的十六进制数组和字符串">内联 Vector 定义的十六进制数组和字符串</a></h3>
<p>Vector 也可以表示字符串。VM支持将<code>vector&lt;u8&gt;</code>作为参数传递给<code>main</code>脚本中的函数。</p>
<p>也可以使用十六进制字面量（literal）在脚本或模块中定义<code>vector&lt;u8&gt;</code>：</p>
<pre><code class="language-Move">script {

    use 0x1::Vector;

    // this is the way to accept arguments in main
    fun main(name: vector&lt;u8&gt;) {
        let _ = name;

        // and this is how you use literals
        // this is a &quot;hello world&quot; string!
        let str = x&quot;68656c6c6f20776f726c64&quot;;

        // hex literal gives you vector&lt;u8&gt; as well
        Vector::length&lt;u8&gt;(&amp;str);
    }
}
</code></pre>
<p>更简单的方法是使用字符串字面量：</p>
<pre><code class="language-Move">script {

    fun main() {
        let _ = b&quot;hello world&quot;;
    }
}
</code></pre>
<p>它们被视为ASCII字符串，也被解释为vector<u8>。</p>
<h3><a class="header" href="#vector-速查表" id="vector-速查表">Vector 速查表</a></h3>
<p>这是标准库中 Vector 方法的简短列表：</p>
<ul>
<li>创建一个类型为<code>&lt;E&gt;</code>的空向量</li>
</ul>
<pre><code class="language-Move">Vector::empty&lt;E&gt;(): vector&lt;E&gt;;
</code></pre>
<ul>
<li>获取向量的长度</li>
</ul>
<pre><code class="language-Move">Vector::length&lt;E&gt;(v: &amp;vector&lt;E&gt;): u64;
</code></pre>
<ul>
<li>将元素 e 添加到向量末尾</li>
</ul>
<pre><code class="language-Move">Vector::push_back&lt;E&gt;(v: &amp;mut vector&lt;E&gt;, e: E);
</code></pre>
<ul>
<li>获取对向量元素的可变引用。不可变引用可使用<code>Vector::borrow()</code></li>
</ul>
<pre><code>Vector::borrow_mut&lt;E&gt;(v: &amp;mut vector&lt;E&gt;, i: u64): &amp;E;
</code></pre>
<ul>
<li>从向量的末尾取出一个元素</li>
</ul>
<pre><code>Vector::pop_back&lt;E&gt;(v: &amp;mut vector&lt;E&gt;): E;
</code></pre>
<p>标准库中的 Vector 模块：</p>
<ul>
<li>Diem <a href="https://github.com/diem/diem/blob/master/language/stdlib/modules/vector.move">diem/diem</a></li>
<li>Dfinance <a href="https://github.com/dfinance/dvm/blob/master/lang/stdlib/vector.move">dfinance/dvm</a></li>
</ul>
<h1><a class="header" href="#可编程资源" id="可编程资源">可编程资源</a></h1>
<p>这一章，我们终于要学习Move的关键功能<code>Resource</code>了。它使Move变得独一无二，安全且强大。</p>
<p>首先，让我们看一下Diem开发者网站上的关于<code>Resource</code>的要点（将Libra改名为Diem后，原页面已删除）：</p>
<blockquote>
<p>Move的主要功能是提供了自定义资源类型。<em>资源类型为安全的数字资产编码具提供了丰富的可编程性</em>。
<em>资源在Move语言中就是普通的值</em>。它们可以作为数据结构被存储，作为参数被传递给函数，也可以从函数中返回，等等。</p>
</blockquote>
<p>资源是一种特殊的<em>结构体</em>，可以在Move代码中定义和创建，也可以使用现有的资源。因此，我们可以像使用任何其它数据（比如向量或结构体）那样来管理数字资产。</p>
<blockquote>
<p>Move类型系统为资源提供了特殊的安全保证。资源永远不能被复制，重用或丢弃。资源类型只能由定义该类型的模块创建或销毁。这些检查由Move虚拟机通过字节码校验强制执行。Move虚拟机将拒绝运行任何尚未通过字节码校验的代码。</p>
</blockquote>
<p>在<em>所有权和引用</em>一章中，我们学习了Move如何保护作用域以及如何控制变量的所有者作用域。在泛型一章，我们了解到有一种特殊的<em>Kind</em>匹配方式可以将<em>可复制</em>和<em>不可复制</em>类型分开。所有这些功能同时也为资源类型提供了强大的安全性。</p>
<blockquote>
<p>所有Diem货币都使用<em>Diem<CoinType><em>类型实现。例如：假设的美元稳定币被表示为</em>Diem<XUS></em>。*Diem<CoinType>*在Move中并没有特殊地位，每个Move资源都享有相同的安全保护。</p>
</blockquote>
<p>就像Diem货币一样，其它代币或其它类型的资产也可以在Move中表示。</p>
<h3><a class="header" href="#扩展阅读" id="扩展阅读">扩展阅读</a></h3>
<ul>
<li><a href="https://developers.diem.com/docs/technical-papers/move-paper/">Move 白皮书</a></li>
</ul>
<h1><a class="header" href="#发件人作为-signer" id="发件人作为-signer">发件人作为 Signer</a></h1>
<p>在开始使用<em>Resource</em>之前，我们需要了解<code>signer</code>类型以及这种类型存在的原因。</p>
<blockquote>
<p>Signer 是一种原生的类似 Resource 的不可复制的类型，它包含了交易发送者的地址。</p>
</blockquote>
<p>Signer 类型代表了发送者权限。换句话说，使用 signer 意味着可以访问发送者的地址和资源。它与<em>signature</em>没有直接关系，就Move VM而言，它仅表示发送者。</p>
<h3><a class="header" href="#脚本的-signer" id="脚本的-signer">脚本的 Signer</a></h3>
<p>Signer 是原生类型，使用前必须先创建。与 vector 这样的原生类型不同，signer 不能直接在代码中创建，但是可以作为脚本参数传递：</p>
<pre><code class="language-Move">script {
    // signer is a reference type here!
    fun main(account: &amp;signer) {
        let _ = account;
    }
}
</code></pre>
<p>Signer 参数无需手动将其传递到脚本中，VM会自动将它放入你的脚本中。而且，signer 自始至终都只是引用，虽然标准库中可以访问签名者的实际值，但使用此值的函数是私有的，无法在其他任何地方使用或传递signer值。</p>
<blockquote>
<p>当前，约定俗成的 signer 类型的变量名是<em>account</em></p>
</blockquote>
<h3><a class="header" href="#标准库中的-signer-模块" id="标准库中的-signer-模块">标准库中的 Signer 模块</a></h3>
<p>原生类型离不开原生方法, signer 的原生方法包含在<code>0x1::Signer</code>模块中。这个模块相对比较简单，具体可以参考Diem标准库Signer模块的<a href="https://github.com/diem/diem/blob/master/language/stdlib/modules/Signer.move">实现</a>:</p>
<pre><code class="language-Move">module Signer {
    // Borrows the address of the signer
    // Conceptually, you can think of the `signer`
    // as being a resource struct wrapper arround an address
    // ```
    // resource struct Signer { addr: address }
    // ```
    // `borrow_address` borrows this inner field
    native public fun borrow_address(s: &amp;signer): &amp;address;

    // Copies the address of the signer
    public fun address_of(s: &amp;signer): address {
        *borrow_address(s)
    }
}
</code></pre>
<p>如你所见，有两个方法，其中一个是原生方法，另一个 Move 方法使用更方便，因为它使用了取值运算符来复制地址。</p>
<p>该模块的用法也很简单：</p>
<pre><code class="language-Move">script {
    fun main(account: &amp;signer) {
        let _ : address = 0x1::Signer::address_of(account);
    }
}
</code></pre>
<h3><a class="header" href="#模块中的-signer" id="模块中的-signer">模块中的 Signer</a></h3>
<pre><code class="language-Move">module M {
    use 0x1::Signer;

    // let's proxy Signer::address_of
    public fun get_address(account: &amp;signer): address {
        Signer::address_of(account)
    }
}
</code></pre>
<blockquote>
<p>使用<code>&amp;signer</code>作为参数的方法明确表明它正在使用发送者的地址。</p>
</blockquote>
<p>引入<code>signer</code>类型的原因之一是要明确显示哪些方法需要发送者权限，哪些不需要。因此，方法不能欺骗用户未经授权访问其资源。</p>
<h3><a class="header" href="#扩展阅读-1" id="扩展阅读-1">扩展阅读</a></h3>
<ul>
<li><a href="https://community.diem.com/t/signer-type-and-move-to/2894">Diem 社区关于 signer 的讨论</a></li>
<li><a href="https://github.com/diem/diem/issues/3679">引入 signer 的原因</a></li>
<li><a href="https://github.com/diem/diem/pull/3819">引入 signer 的 PR</a></li>
</ul>
<h1><a class="header" href="#什么是资源" id="什么是资源">什么是资源</a></h1>
<p>资源（Resource）是一种类型，它可以安全的表示数字资产。我们知道，资产具有这样的属性：它不能被复制，也不能被丢弃或重新使用。这是对资产的属性的一般性描述，那么如何用Move语言来实现这些属性呢？</p>
<h3><a class="header" href="#定义-1" id="定义-1">定义</a></h3>
<p>资源的定义与结构体类似:</p>
<pre><code class="language-Move">module M {
    resource struct T {
        field: u8
    }
}
</code></pre>
<p>就像结构体一样，资源只能在模块中定义，并且只能被其模块里的函数操作。实际上，资源是一种特殊的结构体，因此结构的所有属性都被资源继承。</p>
<h3><a class="header" href="#资源的限制" id="资源的限制">资源的限制</a></h3>
<p>在代码中，资源类型有几个主要限制：</p>
<ol>
<li>资源存储在帐户下。因此，只有在分配帐户后才会<em>存在</em>，并且只能通过该帐户<em>访问</em>。</li>
<li>一个帐户同一时刻只能容纳一个某类型的资源。</li>
<li>资源不能被复制；与它对应的是一种特殊的<code>kind</code>：<code>resource</code>，它与<code>copyable</code>不同，这一点在泛型章节中已经介绍。</li>
<li>资源必需被<code>使用</code>，这意味着必须将新创建的资源<code>move</code>到某个帐户下，从帐户移出的资源必须被解构或存储在另一个帐户下。</li>
</ol>
<p>理论就这么多，下面让我们看看实际的例子！</p>
<h1><a class="header" href="#资源示例" id="资源示例">资源示例</a></h1>
<p>本节中，我们将学习如何使用资源，包括如何定义资源以及使用该资源的方法。最终我们将得到一份完整的合约，可以作为模板供日后使用。</p>
<p>我们将创建一个集合合约，它的功能包括：</p>
<ul>
<li>创建一个集合</li>
<li>集合中添加、提取元素</li>
<li>回收集合</li>
<li>向其它用户提供收藏品</li>
<li>允许以任何类型使用此模块</li>
</ul>
<p>为了更好地理解本章，建议您使用Move IDE（在入门章节中已经介绍过）并在其中运行所有这些模块和脚本。Move IDE 可以高亮显示可能的错误，并将自动与标准库同步，可以帮助我们验证使用的是正确的函数和地址。</p>
<p>项目的目录结构为：</p>
<pre><code>modules/
    Collection.move
scripts/
    use_collection.move
.mvconfig.json
</code></pre>
<p>.mvconfig中的推荐配置为：</p>
<pre><code class="language-json">{
    &quot;sender&quot;: &quot;0x1&quot;,
    &quot;network&quot;: &quot;libra&quot;
}
</code></pre>
<h1><a class="header" href="#创建和移动资源" id="创建和移动资源">创建和移动资源</a></h1>
<p>首先，让我们创建模块：</p>
<pre><code class="language-Move">// modules/Collection.move
module Collection {


    struct Item {
        // we'll think of the properties later
    }

    resource struct T {
        items: vector&lt;Item&gt;
    }
}
</code></pre>
<blockquote>
<p>一个模块里最主要的资源通常命名为<strong>T</strong>。遵循这个惯例，你的模块将易于阅读和使用。</p>
</blockquote>
<h3><a class="header" href="#创建和移动" id="创建和移动">创建和移动</a></h3>
<p>我们定义了一个资源结构体<code>T</code>，该结构体将保存一个向量，向量里面存放<code>Item</code>类型的元素。现在，让我们看看如何创建新集合以及如何在<em>account</em>下存储资源。资源将永久保存在发送者的地址下，没有人可以从所有者那里修改或取走此资源。</p>
<pre><code class="language-Move">// modules/Collection.move
module Collection {

    use 0x1::Vector;

    struct Item {}

    resource struct T {
        items: vector&lt;Item&gt;
    }

    /// note that &amp;signer type is passed here!
    public fun start_collection(account: &amp;signer) {
        move_to&lt;T&gt;(account, T {
            items: Vector::empty&lt;T&gt;()
        })
    }
}
</code></pre>
<p>还记得<code>signer</code>吗？现在，你将了解它的运作方式！移动资源到account需要使用内建函数<em>move_to</em>，需要signer作为第一个参数，T作为第二个参数。move_to函数的签名可以表示为：</p>
<pre><code class="language-Move">native fun move_to&lt;T: resource&gt;(account: &amp;signer, value: T);
</code></pre>
<p>总结一下上面所学的内容：</p>
<ol>
<li>你只能将资源放在自己的帐户下。你无权访问另一个帐户的<code>signer</code>值，因此无法放置资源到其它账户。</li>
<li>一个地址下最多只能存储一个同一类型的资源。两次执行相同的操作是不行的，比如第二次尝试创建已有资源将会导致失败。</li>
</ol>
<h3><a class="header" href="#查看资源是否存在" id="查看资源是否存在">查看资源是否存在</a></h3>
<p>Move 提供<code>exists</code>函数来查看某资源是否存在于给定地址下，函数签名如下:</p>
<pre><code class="language-Move">native fun exists&lt;T: resource&gt;(addr: address): bool;
</code></pre>
<p>通过使用泛型，此函数成为独立于类型的函数，你可以使用任何资源类型来检查其是否存在于给定地址下。实际上，任何人都可以检查给定地址处是否存在资源。但是检查是否存在并不意味着能获取储资源！</p>
<p>让我们编写一个函数来检查用户是否已经拥有 resource T：</p>
<pre><code class="language-Move">// modules/Collection.move
module Collection {

    struct Item {}

    resource struct T {
        items: Item
    }

    // ... skipped ...

    /// this function will check if resource exists at address
    public fun exists_at(at: address): bool {
        exists&lt;T&gt;(at)
    }
}
</code></pre>
<hr />
<p>现在你已经知道了如何创建资源，如何将其移动到发送者账户下以及如何检查资源是否已经存在，现在是时候学习如何访问和修改资源了。</p>
<h1><a class="header" href="#读取和修改资源" id="读取和修改资源">读取和修改资源</a></h1>
<p>Move 有两个内建函数用来读取和修改资源。它们的名字与功能完全相符：borrow_global和borrow_global_mut。</p>
<h2><a class="header" href="#不可变借用-borrow_global" id="不可变借用-borrow_global">不可变借用 <code>borrow_global</code></a></h2>
<p>在<a href="resources//advanced-topics/ownership-and-references.html">所有权和引用</a> 一章，我们已经了解了可变引用（＆mut）和不可变的引用（＆）。现在是时候实践这些知识了！</p>
<pre><code class="language-Move">// modules/Collection.move
module Collection {

    // added a dependency here!
    use 0x1::Signer;
    use 0x1::Vector;

    struct Item {}
    resource struct T {
        items: vector&lt;Item&gt;
    }

    // ... skipped ...

    /// get collection size
    /// mind keyword acquires!
    public fun size(account: &amp;signer): u64 acquires T {
        let owner = Signer::address_of(account);
        let collection = borrow_global&lt;T&gt;(owner);

        Vector::length(&amp;collection.items)
    }
}
</code></pre>
<p>这里发生了很多事情。首先，让我们看一下函数的签名。全局函数borrow_global<T>返回了对资源T的不可变引用。其签名如下：</p>
<pre><code class="language-Move">native fun borrow_global&lt;T: resource&gt;(addr: address): &amp;T;
</code></pre>
<p>通过使用此功能，我们可以读取存储在特定地址的资源。这意味着该模块（如果实现了此功能）具有读取任何地址上任何资源的能力，当然这里的资源指的是该模块内定义的任何资源。</p>
<p>另一个结论：由于<code>Borrow</code>检查，你不能返回对资源的引用或对其内容的引用（因为对资源的引用将在函数作用域结束时消失）。</p>
<blockquote>
<p>由于资源是不可复制的类型，因此不能在其上使用取值运算符“*”。</p>
</blockquote>
<h3><a class="header" href="#acquires-关键字" id="acquires-关键字">Acquires 关键字</a></h3>
<p>还有另一个值得解释的细节：关键字<code>acquires</code>，该关键字放在函数返回值之后。此关键字显式定义此函数获取的所有资源。你必须指定每个获取的资源，即使它实际上是子函数所获取的资源，即父函数必须在其获取列表中包含子函数的获取列表。</p>
<p>acquires 使用方法如下：</p>
<pre><code class="language-Move">fun &lt;name&gt;(&lt;args...&gt;): &lt;ret_type&gt; acquires T, T1 ... {
</code></pre>
<h2><a class="header" href="#可变借用-borrow_global_mut" id="可变借用-borrow_global_mut">可变借用 <code>borrow_global_mut</code></a></h2>
<p>要获得对资源的可变引用，请添加<code>_mut</code>到<code>borrow_global</code>后，仅此而已。让我们添加一个函数，将新的 Item 添加到集合中。</p>
<pre><code class="language-Move">module Collection {

    // ... skipped ...

    public fun add_item(account: &amp;signer) acquires T {
        let collection = borrow_global_mut&lt;T&gt;(Signer::address_of(account));

        Vector::push_back(&amp;mut collection.items, Item {});
    }
}
</code></pre>
<p>对资源的可变引用允许创建对其内容的可变引用。这就是为什么我们可以在此示例中修改内部向量items的原因。</p>
<pre><code class="language-Move">native fun borrow_global_mut&lt;T: resource&gt;(addr: address): &amp;mut T;
</code></pre>
<h1><a class="header" href="#取出和销毁资源" id="取出和销毁资源">取出和销毁资源</a></h1>
<p>本章的最后一个函数是<code>move_from</code>，它用来将资源从账户下取出。我们将实现<code>destroy</code>函数，将<code>Collection</code>的<code>T</code>资源从账户取出并且销毁它的内容。</p>
<pre><code class="language-Move">// modules/Collection.move
module Collection {

    // ... skipped ...

    public fun destroy(account: &amp;signer) acquires T {

        // account no longer has resource attached
        let collection = move_from&lt;T&gt;(Signer::address_of(account));

        // now we must use resource value - we'll destructure it
        let T { items: _ } = collection;

        // done. resource destroyed
    }
}
</code></pre>
<p>资源必需被<code>使用</code>。因此，从账户下取出资源时，要么将其作为返回值传递，要么将其销毁。但是请记住，即使你将此资源传递到外部并在脚本中获取，接下来能做的操作也非常有限。因为脚本上下文不允许你对结构体或资源做任何事情，除非资源模块中定义了操作资源公开方法，否则只能将其传递到其它地方。知道这一点，就要求我们在设计模块时，为用户提供操作资源的函数。</p>
<p>最后一个函数签名：</p>
<pre><code class="language-Move">native fun move_from&lt;T: resource&gt;(addr: address): T;
</code></pre>
<h1><a class="header" href="#下一步" id="下一步">下一步</a></h1>
<p>在本章中，我们了解了Move语法中如何表示对资源的限制，还学习了如何创建，检查，访问，修改和销毁资源。本章是这本书的最后一章了，如果还想继续深入下去，你可以根据需要修改前面的模块，例如：</p>
<ol>
<li>尝试修改此模块以通过泛型支持任何类型。</li>
<li>阅读 <a href="https://github.com/diem/diem/blob/master/language/stdlib/modules/Offer.move">Offer 模块</a> 并尝试向其它账户提供<code>Collection</code>。</li>
</ol>
<p>可以在<a href="https://github.com/damirka/move-book/blob/master/samples/">GitHub</a> 上找到Collection模块的完整代码。</p>
<h1><a class="header" href="#实例" id="实例">实例</a></h1>
<h1><a class="header" href="#erc20-代币" id="erc20-代币">ERC20 代币</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
