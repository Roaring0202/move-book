<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Move Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> The Move Language</a></li><li class="chapter-item expanded "><a href="introduction/foreword.html"><strong aria-hidden="true">2.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="introduction/move.or.mvir.html"><strong aria-hidden="true">3.</strong> Move or Mvir</a></li><li class="chapter-item expanded "><a href="introduction/getting-started.html"><strong aria-hidden="true">4.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapters/syntax-basics.html"><strong aria-hidden="true">5.</strong> Syntax Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapters/concept.html"><strong aria-hidden="true">5.1.</strong> Concept</a></li><li class="chapter-item expanded "><a href="chapters/primitives.html"><strong aria-hidden="true">5.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="chapters/comments.html"><strong aria-hidden="true">5.3.</strong> Comments</a></li><li class="chapter-item expanded "><a href="chapters/expression-and-scope.html"><strong aria-hidden="true">5.4.</strong> Expression and Scope</a></li><li class="chapter-item expanded "><a href="chapters/control-flow.html"><strong aria-hidden="true">5.5.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="chapters/module.html"><strong aria-hidden="true">5.6.</strong> Module</a></li><li class="chapter-item expanded "><a href="chapters/function.html"><strong aria-hidden="true">5.7.</strong> Function</a></li><li class="chapter-item expanded "><a href="chapters/struct.html"><strong aria-hidden="true">5.8.</strong> Structures</a></li></ol></li><li class="chapter-item expanded "><a href="chapters/advanced-topics.html"><strong aria-hidden="true">6.</strong> Advanced Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapters/ownership.html"><strong aria-hidden="true">6.1.</strong> Ownership and References</a></li><li class="chapter-item expanded "><a href="chapters/generics.html"><strong aria-hidden="true">6.2.</strong> Using Generics</a></li><li class="chapter-item expanded "><a href="chapters/vector.html"><strong aria-hidden="true">6.3.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="chapters/resource.html"><strong aria-hidden="true">6.4.</strong> Resource</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Move Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#move-language" id="move-language">Move Language</a></h1>
<p>Move is a safe and reliable language developed for blockchains by <a href="https://libra.org/">Libra</a>. You can read language white paper on <a href="https://developers.libra.org/docs/assets/papers/libra-move-a-language-with-programmable-resources/2019-09-26.pdf">libra developers website</a>.</p>
<p>This book (or call it a resource for now) is a collection of all the information which my colleagues and I found and shaped into a single source of knowledge about Move language.</p>
<h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<p>It's been few months since we at <a href="https://dfinance.co">dfinance</a> started working with Libra's Move VM and Move language. Before that we worked a lot with blockchains (and smart contracts specifically): you may know our <a href="http://wings.ai">Wings.ai</a> project - once the biggest dApp on ETH network; and we - better than many - know how hard it can be for a newcomer to work with new blockchain language, especially Rust-like, especially when blockchain environments and infrastructure challenges come to play. </p>
<p>That is why we are here - to help you dive into yet unknown language, and to show you its beauty.</p>
<h1><a class="header" href="#move-or-mvir" id="move-or-mvir">Move or Mvir</a></h1>
<p>If you've tried searching any information on Move language or if you have visited <a href="https://developers.libra.org">developers.libra.org</a>, you may have noticed that there're 2 languages right now: Move - the one from whitepaper and fancy news headlines, and Mvir (Move IR) - most documented and mentioned on libra's developers portal.</p>
<p>Why are there two languages? Do they compile/transpile into each other? Is Move IR a middle step between Move and bytecode? The short answer is no. However long answer will require some explanation - let's start with the facts:</p>
<ol>
<li>There's only one VM (which is also called Move VM);</li>
<li>There're two compilers, hence two languages;</li>
</ol>
<p>From what we've known from calibra team, Move IR is a &quot;developer version&quot; of Move which was created to speed up VM development while &quot;the Move language&quot; was being designed. Even though these two languages have different syntax - both compile into bytecode which is supported by Move VM.</p>
<p>You may be asking yourself &quot;what should I choose?&quot;, well currently there's no correct answer to that. Move is Rust-like and simpler, Mvir is pretty hardcore when it comes to references and changes of values; both are supported by VM. According to <a href="https://developers.libra.org/blog/">Libra's blog</a>:</p>
<ol>
<li>In December member of Calibra team wrote that <a href="https://community.libra.org/t/on-move-and-ir/2260/2">Move IR is a prototyping language</a>, and Move will be the main.</li>
<li>New syntax from latest blog posts <a href="https://libra.org/en-US/blog/how-to-use-the-end-to-end-tests-framework-in-move/">looks like Move</a>;</li>
<li><a href="https://libra.org/en-US/blog/libra-core-roadmap-3/">In roadmap #2 retrospective</a> Libra team marks Move IR as a tooling language and separates Move IR and Move language;</li>
<li>Move's standard library <a href="https://github.com/libra/libra/tree/master/language/stdlib/modules">is written in Move</a> and is rapidly growing and developing;</li>
</ol>
<p>In this book you will only meet Move as I believe it is going to be the final Move language.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting started</a></h1>
<p>As with any compiled language, you need proper set of tools to compile, run and debug your Move applications. Since this language is created for blockchains and used only within them, running scripts off-chain is a non-trivial task: every module will require environment, account handling and compile-publishing system.</p>
<p>To simpify development of Move modules we've created <a href="https://github.com/damirka/vscode-move-ide">Move IDE</a> extension for Visual Studio Code. This extension will help you cope with environment requirements. Use of this extension is highly recommended as it will handle build/run environment for you, hence will let you focus on learning Move language instead of struggling with the CLI environment. This extension also includes Move syntax highlighting and run environment to help you debug your applications before going public.</p>
<h2><a class="header" href="#install-move-ide" id="install-move-ide">Install Move IDE</a></h2>
<p>To install it you'll need:</p>
<ol>
<li>VSCode (version 1.43.0 and above) - you can <a href="https://code.visualstudio.com/download">get it here</a>; if you already have one - proceed to the next step;</li>
<li>Move IDE - once VSCode is installed, follow <a href="https://marketplace.visualstudio.com/items?itemName=damirka.move-ide">this link</a> to install newest version of IDE.</li>
</ol>
<h3><a class="header" href="#setup-environment" id="setup-environment">Setup environment</a></h3>
<p>Move IDE proposes single way of organizing your directory structure. Create new directory for your project and open it in VSCode. Then setup this directory structure:</p>
<pre><code>modules/   - directory for our modules
scripts/   - directory for transaction scripts
out/       - this directory will hold compiled sources
</code></pre>
<p>Also you'll need to create file called <code>.mvconfig.json</code> which will configure your working environment. This is a sample for <code>libra</code>:</p>
<pre><code class="language-json">{
    &quot;network&quot;: &quot;libra&quot;,
    &quot;sender&quot;: &quot;0x1&quot;
}
</code></pre>
<p>Alternatively you can use <code>dfinance</code> as network:</p>
<pre><code class="language-json">{
    &quot;network&quot;: &quot;dfinance&quot;,
    &quot;sender&quot;: &quot;0x1&quot;
}
</code></pre>
<blockquote>
<p>dfinance uses bech32 'wallet1...' addresses, libra uses 16-byte '0x...' addresses. For local runs and experiments 0x1 address is enough - it's simple and short. Though when working with real blockchains in testnet or production environment you'll have to use correct address of network you've chosen.</p>
</blockquote>
<h2><a class="header" href="#your-very-first-application-with-move" id="your-very-first-application-with-move">Your very first application with Move</a></h2>
<p>Move IDE allows you to run scripts in testing environment. Let's see how it works by implementing <code>gimme_five()</code> function and running it inside VSCode.</p>
<h3><a class="header" href="#create-module" id="create-module">Create module</a></h3>
<p>Create new file called <code>hello_world.move</code> inside <code>modules/</code> directory of your project.</p>
<pre><code class="language-Move">// modules/hello_world.move
address 0x1 {
module HelloWorld {
    public fun gimme_five(): u8 {
        5
    }
}s
}
</code></pre>
<blockquote>
<p>If you decided to use your own address (not <code>0x1</code>) - make sure you've changed 0x1 in this file and the one below</p>
</blockquote>
<h3><a class="header" href="#write-script" id="write-script">Write script</a></h3>
<p>Then create a script, let's call it <code>me.move</code> inside <code>scripts/</code> directory:</p>
<pre><code class="language-Move">// scripts/run_hello.move
script {
    use 0x1::HelloWorld;
    use 0x0::Debug;

    fun main() {
        let five = HelloWorld::gimme_five();

        Debug::print&lt;u8&gt;(&amp;five);
    }
}
</code></pre>
<p>Then, while keeping your script open follow these steps:</p>
<ol>
<li>Toggle VSCode's command palette by pressing <code>⌘+Shift+P</code> (on Mac) or <code>Ctrl+Shift+P</code> (on Linux/Windows)</li>
<li>Type: <code>&gt;Move: Run Script</code> and press enter or click when you see the right option.</li>
</ol>
<p>Voila! You should see execution result - log message with '5' printed in debug. If you don't see this window, go through this part again.</p>
<p>Your directory structure should look like this:</p>
<pre><code>modules/
  hello_world.move
scripts/
  run_hello.move
out/
.mvconfig.json
</code></pre>
<blockquote>
<p>You can have as many modules as you want in your modules directory; all of them will be accessible in your scripts under address which you've specified in .mvconfig.json</p>
</blockquote>
<h1><a class="header" href="#syntax-basics" id="syntax-basics">Syntax Basics</a></h1>
<p>In this chapter you'll get to know Move language. We'll start with very simple and basic grammar rules and intensity will increase from one chapter to another. If you're a skilled developer this may seem too easy at first glance, but I do recommend you to take a closer look. If you're a beginner, then this part will give you everything you need to know about Move basics.</p>
<h1><a class="header" href="#concept" id="concept">Concept</a></h1>
<p>Unlike other blockchain languages (e.g. Solidity) Move proposes separation of <em>scrips</em> (or <em>transaction-as-script</em>) and <em>modules</em>. The former allows you to put more logic into your transactions and make them more flexible while saving your time and resources; and the latter allows developers to extend blockchain functionality or to implement custom <em>smart-contracts</em> with variety of options.</p>
<p>In basics we'll start with scripts as they're pretty friendly for a newcomer, and then we'll get to modules.</p>
<h1><a class="header" href="#primitive-types" id="primitive-types">Primitive Types</a></h1>
<p>In this section you'll find examples and short descriptions of Move's primitive types: integers (u8, u64, u128), <code>boolean</code> and <code>address</code>. You will also learn how to change size of integer values and what types of addresses are supported in different versions of Move VM.</p>
<!-- MB ADD NOTE: Also, there are no floating point types or strings. -->
<h2><a class="header" href="#integer-types" id="integer-types">Integer types</a></h2>
<p>Integers are represented by <code>u8</code>, <code>u64</code> and <code>u128</code>; Possible integer notations are:</p>
<pre><code class="language-Move">script {
    fun main() {
        // define empty variable, set value later
        let a: u8;
        a = 10;

        // define variable, set type
        let a: u64 = 10;

        // finally simple assignment
        let a = 10;

        // simple assignment with defined value type
        let a = 10u128;

        // in function calls or expressions you can use ints as constant values
        if (a &lt; 10) {};

        // or like this, with type
        if (a &lt; 10u8) {}; // usually you don't need to specify type
    }
}
</code></pre>
<h3><a class="header" href="#operator-as" id="operator-as">Operator <code>as</code></a></h3>
<p>When you need to compare values or when function argument requires integer of different size you can cast your integer variable to another size by using operator <code>as</code>:</p>
<pre><code class="language-Move">script {
    fun main() {
        let a: u8 = 10;
        let b: u64 = 100;

        // we can only compare same size integers
        if (a == (b as u8)) abort 11;
        if ((a as u64) == b) abort 11;
    }
}
</code></pre>
<h2><a class="header" href="#boolean" id="boolean">Boolean</a></h2>
<p>Boolean type is just the one you're used to. Two constant values: <code>false</code> and <code>true</code> - both can only mean one thing - a value of <code>bool</code> type.</p>
<pre><code class="language-Move">script {
    fun main() {
        // these are all the ways to do it
        let b : bool; b = true;
        let b : bool = true;
        let b = true
        let b = false; // here's an example with false
    }
}
</code></pre>
<h2><a class="header" href="#address" id="address">Address</a></h2>
<p>Address is an identifier of sender (or wallet) in blockchain. The very basic operations which require address type are sending coins and importing module.</p>
<pre><code class="language-Move">script {
    fun main() {
        let addr: address; // type identifier

        // in this book I'll use {{sender}} notation;
        // always replace `{{sender}}` in examples with VM specific address!!!
        addr = {{sender}};

        // in Libra's Move VM - 16-byte address in HEX
        addr = 0x...;

        // in dfinance's DVM - bech32 encoded address with `wallet1` prefix
        addr = wallet1....;
    }
}
</code></pre>
<h1><a class="header" href="#comments" id="comments">Comments</a></h1>
<p>If you feel like some places in your code require additional explanation, use <em>comments</em>. Comments are non-executable blocks or lines of text aimed to describe some pieces of the code.</p>
<h3><a class="header" href="#line-comments" id="line-comments">Line comments</a></h3>
<pre><code class="language-Move">script {
    fun main() {
        // this is a comment line
    }
}
</code></pre>
<p>You can use double-slash &quot;<em>//</em>&quot; to write line comments. Rules are simple - <strong>everything after</strong> &quot;<em>//</em>&quot; is considered a comment to the end of line. You can use line comments to leave short notes for other developers or to <em>comment out</em> some code to remove it from execution chain.</p>
<pre><code class="language-Move">script {
    // let's add a note to everything!
    fun main() {
        let a = 10;
        // let b = 10 this line is commented and won't be executed
        let b = 5; // here comment is placed after code
        a + b // result is 15, not 10!
    }
}
</code></pre>
<h3><a class="header" href="#block-comments" id="block-comments">Block comments</a></h3>
<p>If you don't want to comment all the line contents, or if you want to comment out more than one line you can use block comments.</p>
<p>Block comment starts with slash-asterisk <em>/*</em> and includes all the text before first asterisk-slash <em>*/</em>. Block comment is not limited by one line and gives you power of making a note in absolutely any place in code.</p>
<pre><code class="language-Move">script {
    fun /* you can comment everywhere */ main() {
        /* here
           there
           everywhere */ let a = 10;
        let b = /* even here */ 10; /* and again */
        a + b
    }
    /* you can use it to remove certain expressions or definitions
    fun empty_commented_out() {

    }
    */
}
</code></pre>
<p>Of course this example is ridiculous! But it clearly shows the power of block comment. Feel free to comment anywhere!</p>
<h1><a class="header" href="#expression-and-scope" id="expression-and-scope">Expression and Scope</a></h1>
<p>In programming languages expression is a unit of code which returns a value. A function call with return value is an expression - it returns value; an integer (or bool or address) literal is also an expression - it has the value of its integer type and so on.</p>
<blockquote>
<p>Every expression in Move MUST end with semicolon*</p>
</blockquote>
<h3><a class="header" href="#literal-expressions" id="literal-expressions">Literal expressions</a></h3>
<p>Look at the code below. Every line contains an expression which ends with semicolon. Last line has three expressions separated by semicolons.</p>
<pre><code class="language-Move">script {
    fun main() {
        10;
        10 + 5;
        true;
        true != false;
        0x0;
        1; 2; 3;
    }
}
</code></pre>
<p>Good. You now know the simplest expressions there are. But why do we need them? And how to use? It's time to know <code>let</code> keyword.</p>
<h3><a class="header" href="#variables-and-let-keyword" id="variables-and-let-keyword">Variables and <code>let</code> keyword</a></h3>
<p>To store expression value inside variable (to pass it somewhere) you have keyword <code>let</code> (you've already seen it in <a href="chapters//chapters/primitives.html">primitives chapter</a>). It creates a new variable either empty (undefined) or with value of expression.</p>
<pre><code class="language-Move">script {
    fun main() {
        let a;
        let b = true;
        let c = 10;
        let d = 0x0;
        a = c;
    }
}
</code></pre>
<blockquote>
<p>Keword <code>let</code> creates new variable inside <em>current scope</em> and optionally <em>initializes</em> this variable with value. Syntax for this expression is: <code>let &lt;VARIABLE&gt;;</code> or <code>let &lt;VARIABLE&gt; = &lt;EXPRESSION&gt;</code>.</p>
</blockquote>
<p>After you've created and initialized variable you're able to <em>modify</em> or <em>access</em> its value by using variable name. In example above variable <code>a</code> was initialized in the end of function and was <em>assigned</em> a value of variable <code>c</code>.</p>
<blockquote>
<p>Equality sign <code>=</code> is an assignment operator. It assigns right-hand-side expression to left-hand-side variable. Example: <code>a = 10</code> - variable <code>a</code> is assigned an integer value of <code>10</code>.</p>
</blockquote>
<h3><a class="header" href="#underscore-_-to-mark-unused" id="underscore-_-to-mark-unused">Underscore &quot;_&quot; to mark unused</a></h3>
<p>In Move every variable must be used (otherwise your code won't compile), hence you can't initialize one and leave it untouched. Though you have one way to mark variable as <em>intentionally unused</em> - by using underscore <code>_</code>.</p>
<p>You'll get an error if you try to compile this script:</p>
<pre><code class="language-Move">script {
    fun main() {
        let a = 1;
    }
}
</code></pre>
<p>The error:</p>
<pre><code>
    ┌── /scripts/script.move:3:13 ───
    │
 33 │         let a = 1;
    │             ^ Unused assignment or binding for local 'a'. Consider removing or replacing it with '_'
    │
</code></pre>
<p>Compiler message is pretty clear, so all you have to do in this case is put underscore instead:</p>
<pre><code class="language-Move">script {
    fun main() {
        let _ = 1;
    }
}
</code></pre>
<h3><a class="header" href="#shadowing" id="shadowing">Shadowing</a></h3>
<p>Move allows you to define same variable twice with one limitation - it still needs to be used. In the example above only second <code>a</code> is used. The first one: <code>let a = 1</code> is actually unused as on the next line we <em>redefine</em> <code>a</code> while leaving first one unused.</p>
<pre><code class="language-Move">script {
    fun main() {
        let a = 1;
        let a = 2;
        let _ = a;
    }
}
</code></pre>
<p>Though we still can make it work by using first one:</p>
<pre><code class="language-Move">script {
    fun main() {
        let a = 1;
        let a = a + 2; // though let here is unnecessary
        let _ = a;
    }
}
</code></pre>
<h2><a class="header" href="#block-expression" id="block-expression">Block expression</a></h2>
<p>A block is an expression; it's marked with <em>curly braces</em> - <code>{}</code>. Block can contain other expressions (and other blocks). Function body (as you can see by already familiar curly-braces) is also a block in some sence (with few limitations).</p>
<pre><code class="language-Move">script {
    fun block() {
        { };
        { { }; };
        true;
        {
            true;

            { 10; };
        };
        { { { 10; }; }; };
    }
}
</code></pre>
<h3><a class="header" href="#understanding-scopes" id="understanding-scopes">Understanding scopes</a></h3>
<p>Scope (as it's said in <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)">Wikipedia</a>) is a region of code where binding is valid. In other words - it's a part of code in which variable exists. In Move scope is a block of code surrounded by curly braces - basically a block.</p>
<blockquote>
<p>When defining block you actually define a scope.</p>
</blockquote>
<pre><code class="language-Move">script {
    fun scope_sample() {
        // this is a function scope
        {
            // this is a block scope inside function scope
            {
                // and this is a scope inside scope
                // inside functions scope... etc
            };
        };

        {
            // this is another block inside function scope
        };
    }
}
</code></pre>
<p>As you can see from comments in this sample, scopes are defined by blocks (or functions), they can be nested and there's no limit to how many scopes you can define.</p>
<h3><a class="header" href="#variable-lifetime-and-visibility" id="variable-lifetime-and-visibility">Variable lifetime and visibility</a></h3>
<p>Keyword let creates a variable - you already know that. Though you probably don't know that defined variable will live only inside the scope where it's defined (hence inside nested scopes); simply put - it's unaccessible outside its scope and dies right after this scope's end.</p>
<pre><code class="language-Move">script {
    fun let_scope_sample() {
        let a = 1; // we've defined variable A inside function scope

        {
            let b = 2; // variable B is inside block scope

            {
                // variables A and B are accessible inside
                // nested scopes
                let c = a + b;

            }; // in here C dies

            // we can't write this line
            // let d = c + b;
            // as variable C died with its scope

            // but we can define another C
            let c = b - 1;

        }; // variable C dies, so does C

        // this is impossible
        // let d = b + c;

        // we can define any variables we want
        // no name reservation happened
        let b = a + 1;
        let c = b + 1;

    } // function scope ended - no A, B and C are dead
}
</code></pre>
<blockquote>
<p>Variable lives only within scope (or block) where it's defined. When its scope ends, variable dies.</p>
</blockquote>
<h3><a class="header" href="#block-return-values" id="block-return-values">Block return values</a></h3>
<p>In previous part you've learned that block is an expression but we didn't cover why it is an expression and what is block's return value.</p>
<blockquote>
<p>Block can return a value, it's the value of the last expression inside this block if it's not followed by semicolon</p>
</blockquote>
<p>May sound hard, so I'll give you few examples:</p>
<pre><code class="language-Move">script {
    fun block_ret_sample() {

        // since block is an expression, we can
        // assign it's value to variable with let
        let a = {

            let c = 10;

            c * 1000  // no semicolon!
        }; // scope ended, variable a got value 10000

        let b = {
            a * 1000  // no semi!
        };

        // variable b got value 10000000

        {
            10; // see semi!
        }; // this block does not return a value
    }
}
</code></pre>
<h3><a class="header" href="#summary" id="summary">Summary</a></h3>
<p>Let's keynote main points of this chapter.</p>
<ol>
<li>Every expression must end with semicolon unless it's the return value of block;</li>
<li>Keyword <code>let</code> creates new variable with value or right-hand-side expression which lives as long as the scope in which it's been created;</li>
<li>Block is an expression that may or may not have return value.</li>
</ol>
<p>How to control execution flow and how to use blocks for logic switches - on the next page.</p>
<h1><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h1>
<blockquote>
<p>Work in progress.</p>
</blockquote>
<p>To do something more complex than basic 2+2, to do logic switches and to iterate though complex data you need control operators and expressions.</p>
<h3><a class="header" href="#the-if-expression" id="the-if-expression">The <code>if</code> expression</a></h3>
<p>If you want to run code block when some expression is <code>true</code> you need to use <code>if</code> keyword:</p>
<pre><code class="language-Move">script {
    use 0x0::Transaction;

    fun main(custom_addr: address) {
        if (custom_addr != Transaction::sender()) {
            abort 11
        };

        // alternatively
        if (custom_addr != Transaction::sender()) abort 11
    }
}
</code></pre>
<p>Syntax:</p>
<pre><code class="language-Move">if (&lt;EXPRESSION&gt;) &lt;EXPRESSION&gt;;
</code></pre>
<h3><a class="header" href="#lets-add-else-to-our-ifs" id="lets-add-else-to-our-ifs">Let's add <code>else</code> to our <code>if</code>s!</a></h3>
<p>You can (and sometimes must) add <code>else</code> to your <code>if</code> construction:</p>
<pre><code class="language-Move">script {
    use 0x0::Transaction;

    fun main(custom_addr: address) {
        if (custom_addr != Transaction::sender()) {
            abort 11
        } else {
            let _ = true
        };

        // alternatively
        if (custom_addr != Transaction::sender()) abort 11 else {
            let _ = true
        };
    }
}
</code></pre>
<p>Syntax with <code>else</code>:</p>
<pre><code class="language-Move">if (&lt;EXPRESSION&gt;)
    &lt;EXPRESSION&gt;
else
    &lt;EXPRESSION&gt;;
</code></pre>
<h2><a class="header" href="#using-loops" id="using-loops">Using loops</a></h2>
<p>In Move you have two ways to do repetition: conditional loop with <code>while</code> and infinite <code>loop</code>.</p>
<p>Use while loop with bool expression inside parentheses:</p>
<pre><code class="language-Move">fun main() {

    let i = 0;

    while (i &lt; 5) {
        i = i + 1;
    }
}
</code></pre>
<p>For infinite (non-conditional) loops use <code>loop</code> keyword with expression:</p>
<pre><code class="language-Move">fun main() {
    let i = 0;

    loop {
        i = i + 1;
        if (i == 5) break
    }
}
</code></pre>
<p>Syntax for loops:</p>
<pre><code class="language-Move">while (&lt;EXPRESSION&gt;) &lt;EXPRESSION&gt;;
loop &lt;EXPRESSION&gt;;
</code></pre>
<h3><a class="header" href="#control-loops-with-continue-and-break" id="control-loops-with-continue-and-break">Control loops with <code>continue</code> and <code>break</code></a></h3>
<p>Keywords <code>continue</code> and <code>break</code> allow you to skip one round or break iteration.</p>
<p>For example let's add two conditions into <code>loop</code>. If <code>i</code> is even we use <code>continue</code> to jump to next iteration without going through code after <code>continue</code> call.
With <code>break</code> we stop iteration and exit loop.</p>
<pre><code class="language-Move">fun main() {
    let i = 0;

    loop {
        i = i + 1;

        if (i / 2 == 0) continue;
        if (i == 5) break;

        // assume we do something here
    };

    // i here is 5
}
</code></pre>
<p>About semicolons. If <code>break</code> and <code>continue</code> are the last keywords in scope, you can't put a semicolon after them as any code after won't be executed. Somehow even semi can't be put. See this:</p>
<pre><code class="language-Move">fun main() {
    let i = 0;

    loop {
        i = i + 1;

        if (i == 5) {
            break; // will result in compiler error. correct is `break` without semi
                   // Error: Unreachable code
        }

        // same with continue here: no semi, never;
        if (true) {
            continue
        }

        // however you can put semi like this, because continue and break here
        // are single expressions, hence they &quot;end their own scope&quot;
        if (true) continue;
        if (i == 5) break;
    }
}
</code></pre>
<h1><a class="header" href="#module" id="module">Module</a></h1>
<p>Module is set of functions and types packed together which developer publishes under his address. In prevous chapters we only used scripts, though script can only operate with published modules or standard library which itself is a set of modules published under <code>0x0</code> address.</p>
<blockquote>
<p>Module is published under its sender's address. Standard library is published under <code>0x0</code> address.</p>
</blockquote>
<blockquote>
<p>When publishing a module, none of its functions are executed. To use module - use scripts.</p>
</blockquote>
<p>Module starts with <code>module</code> keyword, which is followed by module name and curly braces - inside them module contents is placed.</p>
<pre><code class="language-Move">module Math {

    // module contents

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }
}
</code></pre>
<blockquote>
<p>Module is the only way to publish code accessible for others; new types and resources can too only be defined within module context.</p>
</blockquote>
<p>By default your module will be compiled and published from your address. However if you need to use some modules locally (e.g. for testing or developing) or want to specify your address inside module file, use <code>address &lt;ADDR&gt; {}</code> syntax:</p>
<pre><code class="language-Move">address 0x1 {
module Math {
    // module contents

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }
}
}
</code></pre>
<p><em>Like shown in example: best practice is to keep module line without indentation</em></p>
<h2><a class="header" href="#imports" id="imports">Imports</a></h2>
<p>Default context in Move is empty: the only types you can use are primitives (integers, bool and address), and the only thing you can do within empty context is operate these types and variables while being unable to do something meaningful or useful.</p>
<p>To change that you can import published modules (or standard library).</p>
<h3><a class="header" href="#direct-import" id="direct-import">Direct import</a></h3>
<p>You can use modules by their address directly in your code:</p>
<pre><code class="language-Move">script {
    fun main(a: u8) {
        0x0::Transaction::assert(a == 10, 1);
    }
}
</code></pre>
<p>In this example we've imported module <code>Transaction</code> from address <code>0x0</code> (standard library) and used its method <code>assert(expr: bool, code: u8)</code>.</p>
<h3><a class="header" href="#keyword-use" id="keyword-use">Keyword use</a></h3>
<p>To make code shorter (remember that only 0x0 address is short, actual addresses are pretty long!) and to organize imports you can use keyword <code>use</code>:</p>
<pre><code class="language-Move">use &lt;Address&gt;::&lt;ModuleName&gt;;
</code></pre>
<p>In here <code>&lt;Address&gt;</code> is a publisher's address and <code>&lt;ModuleName&gt;</code> is a name of a module. Pretty simple. Same here, we'll import <code>Transaction</code> module from <code>0x0</code>.</p>
<pre><code class="language-Move">use 0x0::Transaction;
</code></pre>
<h3><a class="header" href="#accessing-modules-contents" id="accessing-modules-contents">Accessing module's contents</a></h3>
<p>To access imported module's methods (or types) use <code>::</code> notation. Simple as that - modules can only have one level of definitions so everything you define in module (publicly) can be accessed via double colon.</p>
<pre><code class="language-Move">script {
    use 0x0::Transaction;

    fun main(addr: address) {
        // here we use method assert() of module Transaction
        // the same way we'd access any other method of any other module
        Transaction::assert(addr == 0x1, 1);
    }
}
</code></pre>
<h3><a class="header" href="#import-in-script" id="import-in-script">Import in script</a></h3>
<p>In scripts imports must be placed inside <code>script {}</code> block:</p>
<pre><code class="language-Move">script {
    use 0x0::Transaction;

    // in just the same way you can import any
    // other module(s). as many as you want!

    fun main() {
        Transaction::assert(true, 1);
    }
}
</code></pre>
<h3><a class="header" href="#import-in-module" id="import-in-module">Import in module</a></h3>
<p>Module imports must be specified inside <code>module {}</code> block:</p>
<pre><code class="language-Move">module Math {
    use 0x0::Transaction;

    // the same way as in scripts
    // you are free to import any number of modules

    public fun equal_or_fail(a: u64, b: u64) {
        Transaction::assert(a == b, 1);
    }
}

</code></pre>
<h3><a class="header" href="#use-meets-as" id="use-meets-as">Use meets as</a></h3>
<p>To resolve naming conflicts (when 2 or more modules have same names) and to shorten you code you can change name of the imported module using keyword <code>as</code>.</p>
<p>Syntax:</p>
<pre><code class="language-Move">use &lt;Address&gt;::&lt;ModuleName&gt; as &lt;Alias&gt;;
</code></pre>
<p>In script:</p>
<pre><code class="language-Move">script {
    use 0x0::Transaction as Tx; // Tx now means Transaction

    fun check_assert() {
        Tx::assert(true, 11);
    }
}
</code></pre>
<p>The same in module:</p>
<pre><code class="language-Move">module Math {
    use 0x0::Vector as Vec;

    fun length(&amp;v: vector&lt;u8&gt;): u64 {
        Vec::length(&amp;v)
    }
}
</code></pre>
<h1><a class="header" href="#function" id="function">Function</a></h1>
<p>Function is the only place of execution in Move. Function starts with <code>fun</code> keyword which is followed by function name, parentheses for arguments and curly braces for body.</p>
<pre><code class="language-Move">fun function_name(arg1: u64, arg2: bool): u64 {
    // function body
}
</code></pre>
<p>You have already seen some in previous chapters. And now you will learn how to use them.</p>
<blockquote>
<p><strong>Note:</strong> in Move functions should be named in <em>snake_case</em> - lowercase with underscores as word separators.</p>
</blockquote>
<h2><a class="header" href="#function-in-script" id="function-in-script">Function in script</a></h2>
<p>Script block can contain only one function which is considered <em>main</em>. This function (possibly with arguments) will be executed as transaction. It is very limited: it cannot return value and should be used to operate other functions in already published modules.</p>
<p>Here's an example of simple script which checks if address exists:</p>
<pre><code class="language-Move">script {
    use 0x0::Account;

    fun main(addr: address) {
        Transaction::assert(Account::exists(addr), 1);
    }
}
</code></pre>
<p>This function can have arguments: in this case it is <code>addr</code> argument with type <code>address</code>, also it can operate imported modules.</p>
<blockquote>
<p><strong>Note:</strong> as there's only one function, you can call it any way you want. Though you may want to follow general programming concepts and call it <strong>main</strong></p>
</blockquote>
<h2><a class="header" href="#function-in-module" id="function-in-module">Function in module</a></h2>
<p>While script context is fairly limited, full potential of functions can only be seen in a module. Let's go through it again: module is a published set of functions and types (we'll get to it in the next chapter) which solves one or many tasks.</p>
<p>In this part we'll create simple Math module which will provide users with basic set of mathematical functions and few helper methods. Most of this could be done without using module, but our goal is education!</p>
<pre><code class="language-Move">module Math {
    fun zero(): u8 {
        0
    }
}
</code></pre>
<p>First step: we've defined a module named <code>Math</code> with one function in it: <code>zero()</code>, which returns 0 - a value of type <code>u8</code>. Remember <a href="chapters//chapters/expression-and-scope.html">expressions</a>? There's no semicolon after <code>0</code> as it is the <em>return value</em> of this function. Just like you would do with block. Yeah, function body is very similar to block.</p>
<h3><a class="header" href="#function-arguments" id="function-arguments">Function arguments</a></h3>
<p>This should be clear by now, but let's repeat. Function can take arguments (values passed into function). As many as needed. Every argument has 2 properties: name - its name within a function body, and type - just like any other variable in Move.</p>
<p>Function arguments - just like any other variables defined within a scope - live only within function body. When function block ends, no variables remain.</p>
<pre><code class="language-Move">module Math {

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }

    fun zero(): u8 {
        0
    }
]
</code></pre>
<p>What's new in our Math: function <code>sum(a,b)</code> which sums two <code>u64</code> values and returns result - <code>u64</code> sum (type can't change).</p>
<p>Let's state few syntax rules:</p>
<ol>
<li>Arguments must have types and must be separated by comma</li>
<li>Function return value is placed after parentheses and must follow a colon</li>
</ol>
<p>Now how would we use this function in script? Through import!</p>
<pre><code class="language-Move">script {
    use 0x1::Math;  // used 0x1 here; could be your address
    use 0x0::Debug; // this one will be covered later!

    fun main(first_num: u64, second_num: u64) {

        // variables names don't have to match the function's ones
        let sum = Math::sum(first_num, second_num);

        Debug::print&lt;u64&gt;(&amp;sum);
    }
}
</code></pre>
<h3><a class="header" href="#multiple-return-values" id="multiple-return-values">Multiple return values</a></h3>
<p>In previous examples we've experimented with functions with no return value or with single. But what if I told you that you can return multiple values of any type? Curious? Let's proceed!</p>
<p>To specify multiple return values you need to use parentheses:</p>
<pre><code class="language-Move">module Math {

    // ...

    public fun max(a: u8, b: u8): (u8, bool) {
        if (a &gt; b) {
            (a, false)
        } else if (a &lt; b) {
            (b, false)
        } else {
            (a, true)
        }
    }
}
</code></pre>
<p>This function takes two arguments: <code>a</code> and <code>b</code> and <em>returns two values</em>: first is the max value from two passed and second is a bool - whether numbers entered are equal. Take closer look at the syntax: instead of specifying singe return argument we've added <em>parenteses</em> and have listed return argument types.</p>
<p>Now let's see how we can use result of this function in another function in script.</p>
<pre><code class="language-Move">script {
    use 0x0::Debug;
    use 0x1::Math;

    fun main(a: u8, b: u8)  {
        let (max, is_equal) = Math::max(99, 100);

        Transaction::assert(is_equal, 1)

        Debug::print&lt;u8&gt;(&amp;max);
    }
}
</code></pre>
<p>In this example we've <em>destructed</em> a tuple: created two new variables with values and types of return values of function <em>max</em>. Order is preserved and variable <em>max</em> here gets type <em>u8</em> and now stores max value, whereas <em>is_equal</em> is a <em>bool</em>.</p>
<p>Two is not the limit - number of returned arguments is up to you, though you'll soon learn about structs and see alternative way to return complex data.</p>
<h3><a class="header" href="#function-visibility" id="function-visibility">Function visibility</a></h3>
<p>When defining a module you may want to make some functions accessible by other developers and some to remain hidden. This is when <em>function visibility modifiers</em> come to play.</p>
<p>By default every function defined in module is private - it cannot be accessed in other modules or scripts. If you've been attentive, you may have noticed that some of the functions that we've defined in our Math module have keyword <code>public</code> before their definition:</p>
<pre><code class="language-Move">module Math {

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }

    fun zero(): u8 {
        0
    }
}
</code></pre>
<p>In this example function <code>sum()</code> is accessible from outside when module is imported, however function <code>zero()</code> is not - it is private by default.</p>
<blockquote>
<p>Keyword <code>public</code> changes function's default <em>private</em> visibility and makes it <em>public</em> - i.e. accessible from outside.</p>
</blockquote>
<p>So basically if you didn't make <code>sum()</code> function <em>public</em>, this wouldn't be possible:</p>
<pre><code class="language-Move">script {
    use 0x1::Math;

    fun main() {
        Math::sum(10, 100); // won't compile!
    }
}
</code></pre>
<h3><a class="header" href="#access-local-functions" id="access-local-functions">Access local functions</a></h3>
<p>There would not be any sence in making private functions if they could not be accessed at all. Private functions exist to do some <em>internal</em> work when public functions are called.</p>
<blockquote>
<p>Private functions can only be accessed in the module where they're defined.</p>
</blockquote>
<p>So how do you access function in the same module? By simply calling this function like it was imported!</p>
<pre><code class="language-Move">module Math {

    public fun is_zero(a: u8): bool {
        a == zero()
    }

    fun zero(): u8 {
        0
    }
}
</code></pre>
<p>Any function defined in a module is acessible by any function in the same module no matter what visibility modifiers any of them has. This way private functions can still be used as calls inside public ones without exposing some private features or too risky operations.</p>
<h3><a class="header" href="#native-functions" id="native-functions">Native functions</a></h3>
<p>There's a special kind of functions - <em>native</em> ones. <em>Native functions</em> implement functionality which goes beyond Move's possibilities and give you extra power. Native functions are defined by VM itself and may vary in different implementations. Which means they don't have implementation in Move syntax and instead of having function body they end with semicolon. Keyword <code>native</code> is used to mark native functions. It does not conflict with function visibility modifiers and same function can be <code>native</code> and <code>public</code> at the same time.</p>
<p>Here's an example from Libra's standard library.</p>
<pre><code class="language-Move">module Transaction {
    // get transaction sender, you can't do it other way
    native public fun sender(): address;

    // ...
}
</code></pre>
<h1><a class="header" href="#struct" id="struct">Struct</a></h1>
<p>Structure is a custom type which contains complex data (or no data). It can be described as a simple key-value storage where key is a name of property and value is what's stored. Defined using keyword <code>struct</code>.</p>
<blockquote>
<p>Struct (and resource struct) is the only way to create custom type in Move. You'll learn more about it later.</p>
</blockquote>
<h2><a class="header" href="#rules" id="rules">Rules</a></h2>
<ol>
<li>Struct definition is possible <strong>only within a module</strong>;</li>
<li>Struct can contain field of any type including another structure;</li>
<li>Structs can only be constructed in the module in which they are declared;</li>
<li>Struct fields can only be accessed within module (therefore they are all private);</li>
<li>Recursive struct definition is impossible;</li>
<li>Struct may not have fields (can be empty).</li>
</ol>
<h2><a class="header" href="#definition-and-usage" id="definition-and-usage">Definition and Usage</a></h2>
<p>Again: <code>struct</code> can be defined only inside module context.</p>
<pre><code class="language-Move">module RecordsCollection {

    // struct can contain no fields it's
    // initialization will be simple:
    // let d = Dummy {};
    struct Dummy {}

    struct Record {
        author_id: u64,
        label_id: u64,
        year: u64,
        is_new: bool
    }

    // we can create new Record in a method
    public fun add_new(author_id: u64, label_id: u64, year: u64): Record {
        // when creating new struct use pattern:
        // &lt;key&gt;: &lt;value&gt;
        Record {
            author_id: author_id,
            label_id: label_id,
            year: year,
            is_new: true
        };

        // you can could also use short notation when variable
        // name matches name of the property
        let record: Record = Record {
            author_id,
            label_id,
            year,
            is_new: true
        };

        record
    }

    // since struct fields can only be accessed within module, you
    // have to provide interface to read structs if you pass it
    // outside of the module
    public fun print_year(r: Record): u64 {

        // to access struct's fields use &quot;.&quot; (dot) notation
        r.year
    }
}
</code></pre>
<p>Let's take a better look at <code>add_new(...)</code> function. Since struct is a new type, it can also be a return type, and you're able to see it in function definition:</p>
<pre><code class="language-Move">public fun add_new(author_id: u64, label_id: u64, year: u64): Record { /* ... */ }
</code></pre>
<p>Okay. How can we use our <code>Record</code> struct after we published <code>VinylShop</code> module into network?</p>
<pre><code class="language-Move">// specify publisher's address

script {
    use {{sender}}::VinylShop;

    fun add_new_record() {
        // we can use type-binding but we can't construct it - Rule #3
        let record : VinylShop::Record = VinylShop::add_new(10, 10, 1999);

        // here we can pass record type but can't use `record.year` - Rule #4
        if (VinylShop::print_year(record) == 1999) abort 11;
    }
}
</code></pre>
<h2><a class="header" href="#destruction" id="destruction">Destruction</a></h2>
<p>In some cases you may need to destroy your struct and get it's contents. This operation called destruction.</p>
<pre><code class="language-Move">module LongLive {

    struct T { value: u8 }

    public fun create(value: u8): T {
        T { value }
    }

    public fun destroy(t: T): u8 {
        let T { value } = T;
        value
    }
}
</code></pre>
<p>Syntax for destructuring is the opposite to creation:</p>
<pre><code>let T { &lt;field1&gt;, &lt;field...&gt; } = T;
</code></pre>
<h1><a class="header" href="#advanced-topics" id="advanced-topics">Advanced Topics</a></h1>
<p>In this part you'll learn Move essentials - features that make Move so unique: ownership model, generics, vector and the most important one - resources.</p>
<h1><a class="header" href="#ownership" id="ownership">Ownership</a></h1>
<p>Move VM implements Rust-like ownership system. And the best description of it is in <a href="https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html">Rust Book</a>. <!-- There's one main difference between two languages: Move does not have *heap*, and all of its variables are *put on stack*. --></p>
<p>I recommend you reading ownership chapter in Rust Book even though Rust syntax differs and some of the examples may not be easy to understand. In this chapter we will go through main points anyway.</p>
<blockquote>
<p>Each variable has only one owner scope. When owner scope ends - owned variables are dropped.</p>
</blockquote>
<p>We've already seen this behavior in <a href="chapters//chapters/expression-and-scope.html">expressions chapter</a>. Remember that variable lives as long as its scope? Now is the perfect time to get under the hood and learn why it happens.</p>
<p>Owner is a scope which <em>owns</em> a variable. Variable either can be defined in this scope (e.g. with keyword <code>let</code> in script) or be passed into scope as argument. Since the only scope in Move is function's - there are no other ways to put variable into scope.</p>
<p>Each variable has only one owner, which means that when variable is passed into function as argument, this function becomes the <em>new owner</em>, and variable no longer <em>owned</em> by the first function. Or you may say that function <em>takes ownership</em> of variable.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        // Module::T is a struct
        let a : Module::T = Module::create(10);

        // here variable `a` leaves scope of `main` function
        // and is being put into new scope of `M::value` function
        M::value(a);

        // variable a no longer exists in this scope
        // this code won't compile
        M::value(a);
    }
}
</code></pre>
<p>Let's look at what happens inside <code>value()</code> when we pass our value into it:</p>
<pre><code class="language-Move">module M {
    // create_fun skipped
    struct T { value: u8 }

    public fun create(value: u8): T {
        T { value }
    }

    // variable t of type M::T passed
    // `value()` function takes ownership
    public fun value(t: T): u8 {
        // we can use t as variable
        t.value
    }
    // function scope ends, t dropped, only u8 result returned
    // t no longer exists
}
</code></pre>
<p>Of course, quick workaround is to return a tuple with original variable and additional results (return value would have been <code>(T, u8)</code>), but Move has a better solution for that.</p>
<h2><a class="header" href="#move-and-copy" id="move-and-copy">Move and Copy</a></h2>
<p>First, you need to understand how Move VM works, and what happens when you pass your value into a function. There are two bytecode instructions in VM: <em>MoveLoc</em> and <em>CopyLoc</em> - both of them can be manually used with keywords <code>move</code> and <code>copy</code> respectively.</p>
<p>When variable is being passed into another function - it's being <em>moved</em> and <em>MoveLoc</em> OpCode is used. Let's see how our code would look if we've used keyword <code>move</code>:</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a : Module::T = Module::create(10);

        M::value(move a); // variable a is moved

        // local a is dropped
    }
}
</code></pre>
<p>This is a valid Move code, however, knowing that value will still be moved you don't need to explicitly <em>move</em> it. Now when it's clear we can get to <em>copy</em>.</p>
<h3><a class="header" href="#keyword-copy" id="keyword-copy">Keyword <code>copy</code></a></h3>
<p>If you need to pass a value to the function (where it's being moved) and save a copy of your variable, you can use keyword <code>copy</code>.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a : Module::T = Module::create(10);

        // we use keyword copy to clone structure
        // can be used as `let a_copy = copy a`
        M::value(copy a);
        M::value(a); // won't fail, a is still here
    }
}
</code></pre>
<p>In this example we've passed <em>copy</em> of variable (hence value) <code>a</code> into first call of method <code>value</code> and saved <code>a</code> in local scope to use it again in second call.</p>
<p>By copying value we've duplicated it and increased memory size of our program, so it can be used - but when you copy huge data it may become pricey in terms of memory. Remember - in blockchains every byte counts and affects price of execution, so using <code>copy</code> all the time may cost you a lot.</p>
<p>Now you are ready to learn about references which help you avoid unnecessary copying and literally save some money.</p>
<h2><a class="header" href="#references" id="references">References</a></h2>
<p>Many programming languages have implementation of references (<a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">see Wikipedia</a>). <em>Reference</em> is a link to variable (usually to a section in memory) which you can pass into other parts of program instead of <em>moving</em> the value.</p>
<blockquote>
<p>References (marked with &amp;) allow you to <em>refer</em> to value without taking <em>ownership</em> of it</p>
</blockquote>
<p>Let's modify our example and see how references can be used.</p>
<pre><code class="language-Move">module M {
    struct T { value: u8 }
    // ...
    // ...
    // instead of passing a value, we'll pass a reference
    public fun value(t: &amp;T): u8 {
        t.value
    }
}
</code></pre>
<p>We added ampersand <code>&amp;</code> to argument type T - and by doing that we've changed argument type from <code>T</code> to <em>reference to T</em> or simply <code>&amp;T</code>.</p>
<blockquote>
<p>Move supports two types of references: <em>immutable</em> - defined with <code>&amp;</code> (e.g. <code>&amp;T</code>) and <em>mutable</em> - <code>&amp;mut</code> (e.g. <code>&amp;mut T</code>).</p>
</blockquote>
<p>Immutable references allow reading value without changing it. Mutable - the opposite - give ability to read and change the value.</p>
<pre><code class="language-Move">module M {
    struct T { value: u8 }

    // returned value is of non-reference type
    public fun create(value: u8): T {
        T { value }
    }

    // immutable references allow reading
    public fun value(t: &amp;T): u8 {
        t.value
    }

    // mutable references allow reading and changing the value
    public fun change(t: &amp;mut T, value: u8) {
        t.value = value;
    }
}
</code></pre>
<p>Now let's see how to use our upgraded module M.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let t = M::create(10);

        // create a reference directly
        M::change(&amp;mut t, 20);

        // or write reference to a variable
        let mut_ref_t = &amp;mut t;

        M::change(mut_ref_t, 100);

        // same with immutable ref
        let value = M::value(&amp;t);

        // this method also takes only references
        // printed value will be 100
        0x0::Debug::print&lt;u8&gt;(&amp;value);
    }
}
</code></pre>
<blockquote>
<p>Only one mutable reference is allowed at the time for a singe value. Immutable references don't change the value and do not have this limit.</p>
</blockquote>
<!-- ## Move and Copy -->
<h3><a class="header" href="#deferencing" id="deferencing">Deferencing</a></h3>
<p>References can be dereferenced to get linked value - to do it use asterisk <code>*</code>.</p>
<blockquote>
<p>When dereferencing you're actually making a <em>copy</em> - avoid</p>
</blockquote>
<pre><code class="language-Move">module M {
    struct T {}

    // value t here is of reference type
    public fun deref(t: &amp;T): T {
        *t
    }
}
</code></pre>
<blockquote>
<p>Dereference operator does not move original value into current scope. It creates a <em>copy</em> of this value instead.</p>
</blockquote>
<h3><a class="header" href="#referencing-primitive-types" id="referencing-primitive-types">Referencing primitive types</a></h3>
<p>Primitive types (due to their simplicity) do not need to be passed as references and <em>copy</em> operation is done instead. Even if you pass them into function <em>by value</em> they will remain in current scope. You can intentionally use <code>move</code> keyword, but since primitives are very small in size copying them may even be cheaper than passing them by reference or even moving.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a = 10;
        M::do_smth(a);
        let _ = a;
    }
}
</code></pre>
<p>This script will compile even though we didn't pass <code>a</code> as a reference. Adding <code>copy</code> is unnecessary - it's already put there by VM.</p>
<!--

Notes:

 - blocks are simply syntax sugar to simplify scripting, they don't set restrictions to using


-->
<!-- unless explicit `move` keyword used -->
<!--

To note here:

[x] references
[x] mutable
[x] only one mutable
[x] immutable
[x] reference as fun arg
[x] access by ref, get value
[ ] why primitives can be passed freely

[ ] kw copy, kw move
[ ] 1 mutable - example!

In generics:

resource
copyable

-->
<h1><a class="header" href="#generics" id="generics">Generics</a></h1>
<p>Generics are essential to Move, they are what makes this language so unique to blockchain world, and they are the source of Move's flexibility.</p>
<p>To start I'll quote <a href="https://doc.rust-lang.org/stable/book/ch10-00-generics.html">Rust Book</a>: <em>Generics are abstract stand-ins for concrete types or other properties</em>. Practically speaking, they are the way of writing single function, which can then be used for any type, they can also be called templates as this function can be used as a template handler for any type.</p>
<p>In Move generics can be applied to signatures of <code>struct</code>, <code>function</code> and <code>resource</code>.</p>
<h3><a class="header" href="#in-struct-definition" id="in-struct-definition">In struct definition</a></h3>
<p>First, we'll create a Box which will hold <code>u64</code> value. We've already been through this, so no need for comments.</p>
<pre><code class="language-Move">module Storage {
    struct Box {
        value: u64
    }
}
</code></pre>
<p>This box can only contain value of <code>u64</code> type - this is clear. But what if we wanted to make the same box for <code>u8</code> type or a <code>bool</code>? Would we create type <code>Box1</code> and then <code>Box2</code>? Or would we publish another module for that? The answer is no - use generics instead.</p>
<pre><code class="language-Move">module Storage {
    struct Box&lt;T&gt; {
        value: T
    }
}
</code></pre>
<p>Next to struct name we've placed <code>&lt;T&gt;</code>. Where angle brackets <code>&lt;..&gt;</code> is a place to define generic types, and <code>T</code> is a type we've <em>templated</em> in this struct. Inside the struct body definition we've used <code>T</code> as a regular type. Type T does not exist, it is a placeholder for <em>any type</em>.</p>
<h3><a class="header" href="#in-function-signature" id="in-function-signature">In function signature</a></h3>
<p>Now let's create constructor for this struct which will first use type <code>u64</code> for value.</p>
<pre><code class="language-Move">module Storage {
    struct Box&lt;T&gt; {
        value: T
    }

    // type u64 is put into angle brackets meaning
    // that we're using Box with type u64
    public fun create_box(value: u64): Box&lt;u64&gt; {
        Box&lt;u64&gt;{ value }
    }
}
</code></pre>
<p>Generics have a bit more complicated definitions - since they need to have type parameters specified, and regular struct <code>Box</code> becomes <code>Box&lt;u64&gt;</code>. There are no restrictions in what types you can pass into generic's angle brackets. Let's make our <code>create_box</code> method more gereric and let users specify any type. How do we do that? Using another generic, now in function signature!</p>
<pre><code class="language-Move">module Storage {
    // ...
    public fun create_box&lt;T&gt;(value: T): Box&lt;T&gt; {
        Box&lt;T&gt; { value }
    }

    // we'll get to this a bit later, trust me
    public fun value&lt;T: copyable&gt;(box: &amp;Box&lt;T&gt;): T {
        *&amp;box.value
    }
}
</code></pre>
<h3><a class="header" href="#in-function-calls" id="in-function-calls">In function calls</a></h3>
<p>What we did is we added angle brackets into function signature right after function name. Just the same way as we did with struct. Now how would we use this function? By specifying type in function call.</p>
<pre><code class="language-Move">script {
    use {{sender}}::Storage;
    use 0x0::Transaction;
    use 0x0::Debug;

    fun main() {
        // value will be of type Storage::Box&lt;bool&gt;
        let bool_box = Storage::create_box&lt;bool&gt;(true);
        let bool_val = Storage::value(&amp;bool_box);

        Transaction::assert(bool_val, 0);

        // we can do the same with integer
        let u64_box = Storage::create_box&lt;u64&gt;(1000000);
        let _ = Storage::value(&amp;u64_box);

        // let's do the same with another box!
        let u64_box_in_box = Storage::create_box&lt;Storage::Box&lt;u64&gt;&gt;(u64_box);

        // accessing value of this box in box will be tricky :)
        // Box&lt;u64&gt; is a type and Box&lt;Box&lt;u64&gt;&gt; is also a type
        let value: u64 = Storage::value&lt;u64&gt;(
            &amp;Storage::value&lt;Storage::Box&lt;u64&gt;&gt;( // Box&lt;u64&gt; type
                &amp;u64_box_in_box // Box&lt;Box&lt;u64&gt;&gt; type
            )
        );

        // you've already seed Debug::print&lt;T&gt; method
        // which also uses generics to print any type
        Debug::print&lt;u64&gt;(&amp;value);
    }
}
</code></pre>
<p>Here we have used Box struct with 3 types: <code>bool</code>, <code>u64</code> and with <code>Box&lt;u64&gt;</code> - last one may seem way too complicated but once you've gotten used to it and understood how it works, it becomes part of your routine.</p>
<!-- , Move opens in new way - the way you probably could never imagine in blockchains. -->
<p>Before we go any further, let's take a step back. By adding generics to <code>Box</code> struct we've made this box <em>abstract</em> - it's definition is fairly simple compared to capacity it gave us. Now we can create <code>Box</code> with any type - be it <code>u64</code> or <code>address</code>, or even another box, or another struct.</p>
<h3><a class="header" href="#multiple-types-in-generics" id="multiple-types-in-generics">Multiple types in generics</a></h3>
<p>Just like you can use single type, you can use many. Generic types are put into angle brackets and separated by comma. Let's add new type <code>Shelf</code> which will hold two boxes of two different types.</p>
<pre><code class="language-Move">module Storage {

    struct Box&lt;T&gt; {
        value: T
    }

    struct Shelf&lt;T1, T2&gt; {
        box_1: Box&lt;T1&gt;,
        box_2: Box&lt;T2&gt;
    }

    public fun create_shelf&lt;Type1, Type2&gt;(
        box_1: Box&lt;Type1&gt;,
        box_2: Box&lt;Type2&gt;
    ): Shelf&lt;Type1, Type2&gt; {
        Shelf {
            box_1,
            box_2
        }
    }
}
</code></pre>
<p>Type paramereters for <code>Shelf</code> are listed and matched inside struct's fields definition. Also, as you can see, name of the type parameter inside generics does not matter - it's up to you to chose a proper one. And each type parameter is only valid within definition so no need to match <code>T1</code> or <code>T2</code> with <code>T</code>.</p>
<p>Using multiple generic type parameters is similar to using single:</p>
<pre><code class="language-Move">script {
    use {{sender}}::Storage;

    fun main() {
        let b1 = Storage::create_box&lt;u64&gt;(100);
        let b2 = Storage::create_box&lt;u64&gt;(200);

        // you can use any types - so same ones are also valid
        let _ = Storage::create_shelf&lt;u64, u64&gt;(b1, b2);
    }
}
</code></pre>
<h3><a class="header" href="#unused-type-params" id="unused-type-params">Unused type params</a></h3>
<p>Not every type specified in generic must be used. Look at this example:</p>
<pre><code class="language-Move">module Storage {

    // these two types will be used to mark
    // where box will be sent when it's taken from shelf
    struct Abroad {}
    struct Local {}

    // modified Box will have target property
    struct Box&lt;T, Destination&gt; {
        value: T
    }

    public fun create_box&lt;T, Dest&gt;(value: T): Box&lt;T, Dest&gt; {
        Box { value }
    }
}
</code></pre>
<p>In script this can be used :</p>
<pre><code class="language-Move">
script {
    use {{sender}}::Storage;

    fun main() {
        // value will be of type Storage::Box&lt;bool&gt;
        let _ = Storage::create_box&lt;bool, Storage::Abroad&gt;(true);
        let _ = Storage::create_box&lt;u64, Storage::Abroad&gt;(1000);

        let _ = Storage::create_box&lt;u128, Storage::Local&gt;(1000);
        let _ = Storage::create_box&lt;address, Storage::Local&gt;(0x0);

        // or even u64 destination!
        let _ = Storage::create_box&lt;address, u64&gt;(0x0);
    }
}
</code></pre>
<p>Here we use generics to mark type, but we don't actually use it. You'll soon learn why this definition matters when you get to know <code>resources</code>. For now it's just another way to use them.</p>
<h3><a class="header" href="#forced-type-params" id="forced-type-params">Forced type params</a></h3>
<h3><a class="header" href="#kind-matching-and-copyable" id="kind-matching-and-copyable">Kind-matching and :copyable</a></h3>
<!--
  + generics in general
  + templating
  + example
  + back to types
  + multiple type params

  unused type params
  hard-coded types
  trait-like bounds - introducing kinds
-->
<h1><a class="header" href="#vector" id="vector">Vector</a></h1>
<p>Vector is a built-in (native) complex type for storing collection of values of one type.</p>
<h2><a class="header" href="#rules-1" id="rules-1">Rules</a></h2>
<p>As usual - let's start with rules.</p>
<ol>
<li>Vector is a native type (just like <a href="chapters//chapters/primitives.html">primitives</a>) which means you can use it in both modules and scripts;</li>
<li>Vector can only contain items of the same type. You cannot store elements of type A and type B in the same vector;</li>
<li>Vector can have size from 0 to 9,223,372,036,854,775,807 (max size of <code>u64</code>), it's called length;</li>
<li>Type of stored value is specified as type parameter: <code>vector&lt;Element&gt;</code>;</li>
<li>Since it's a native type, to use it you need standard library - usually <code>0x0::Vector</code>.</li>
</ol>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<p>As said above you can use it everywhere. In module:</p>
<pre><code class="language-Move">module Countries {
    struct Country {
        name: vector&lt;u8&gt;
    }

    resource struct CountriesList {
        value: vector&lt;Country&gt;
    }
}

</code></pre>
<p>And in script!</p>
<pre><code class="language-Move">script {

    use 0x0::Vector;

    fun vector_example() {
        let collection = Vector::empty&lt;u8&gt;();

        Vector::push_back&lt;u8&gt;(&amp;mut collection, 10);
    }
}
</code></pre>
<p>In this example we've created an empty vector of <code>u8</code> integers and filled it with one value. Please note that vector creation within code is only possible via <code>0x0::Vector</code> library since this type is native.</p>
<h2><a class="header" href="#0x0vector-module" id="0x0vector-module">0x0::Vector module</a></h2>
<p>To manage collection properly we'd need to be able to get its length, to access elements of this collection, and to modify its contents. All of this can be done with standard library (and only with standard library).</p>
<p>Here's a short list of methods available:</p>
<ul>
<li>Create an empty vector of type &lt;E&gt;</li>
</ul>
<pre><code class="language-Move">Vector::empty&lt;E&gt;(): vector&lt;E&gt;;
</code></pre>
<ul>
<li>Get length of a vector</li>
</ul>
<pre><code class="language-Move">Vector::length&lt;E&gt;(v: &amp;vector&lt;E&gt;): u64;
</code></pre>
<ul>
<li>Push element to the end of the vector:</li>
</ul>
<pre><code class="language-Move">Vector::push_back&lt;E&gt;(v: &amp;mut vector&lt;E&gt;, e: E);
</code></pre>
<ul>
<li>Get mutable reference to element of vector. For immutable borrow use <code>Vector::borrow()</code></li>
</ul>
<pre><code>Vector::borrow_mut&lt;E&gt;(v: &amp;mut vector&lt;E&gt;, i: u64): &amp;E;
</code></pre>
<ul>
<li>Pop an element from the end of vector:</li>
</ul>
<pre><code>Vector::pop_back&lt;E&gt;(v: &amp;mut vector&lt;E&gt;): E;
</code></pre>
<p>This list is just enough to start working with vector, but to know full potential of vector you must see these standard libraries:</p>
<ul>
<li>Libra <a href="https://github.com/libra/libra/blob/master/language/stdlib/modules/vector.move">libra/libra</a></li>
<li>Dfinance <a href="https://github.com/dfinance/dvm/blob/master/lang/stdlib/vector.move">dfinance/dvm</a></li>
</ul>
<h1><a class="header" href="#resources" id="resources">Resources</a></h1>
<p>Resources are what makes Move unique, safe and powerful.
First, let's see description from <a href="https://developers.libra.org/docs/move-overview#move-has-first-class-resources">libra developers portal</a>:</p>
<blockquote>
<ul>
<li>The key feature of Move is the ability to define custom resource types. <strong>Resource types are used to encode safe digital assets with rich programmability</strong>.</li>
<li><strong>Resources are ordinary values in the language</strong>. They can be stored as data structures, passed as arguments to procedures, returned from procedures, and so on.</li>
<li><strong>The Move type system provides special safety guarantees for resources</strong>. Move resources can never be duplicated, reused, or discarded. A resource type can only be created or destroyed by the module that defines the type. These guarantees are enforced statically by the Move virtual machine via bytecode verification. The Move virtual machine will refuse to run code that has not passed through the bytecode verifier.</li>
<li>The Libra currency is implemented as a resource type named LibraCoin.T. LibraCoin.T has no special status in the language; every Move resource enjoys the same protections.</li>
</ul>
</blockquote>
<!-- ## Resource concept

Imagine you open a safe deposit box at the bank. Since it's a bank you trust it with alls the contents of your deposit box, and you know that bank will guard it and manage access policy correctly so you and only you (except special occasions in your agreement) can control contents of this deposit box.

What could be the properties of this deposit box?

- an owner - it is you
- it's created for owner (you) by bank - trusted side
- deposit box's access policy is managed by bank and you know it before signing
- deposit box may contain anything - there's no limit
- deposit box can be moved or destroyed by you or by bank (if your agreement allows it)
- deposit box access may be shared (again - if it's specified in terms)

That's pretty much what's going on in Move. Every resource is a deposit box and just like deposit box - it is user-specific. For each user deposit deal goes full path from creation (or *initialization*) to using (or *modification*) and optionally to *destruction*. I suggest you keep in mind this analogy as it will help you understand resource concept. -->
<h2><a class="header" href="#resource-life-time" id="resource-life-time">Resource life time</a></h2>
<p>Resource in Move is defined as a <code>resource struct</code> and just like <code>struct</code> it can only be defined within module context, and unlike struct, resource will outlive your script. To understand that let's look at this example:</p>
<pre><code class="language-Move">// here's our module to manage records on chain
module RecordsCollection {

    use 0x0::Transaction as Tx;

    // the very basic information about our record
    struct Record {
        name: vector&lt;u8&gt;,
        author: vector&lt;u8&gt;,
        year: u64
    }

    // imaginary collection of records
    struct Collection {
        records: vector&lt;Record&gt;
    }

    public fun create_record(name: vector&lt;u8&gt;, author: vector&lt;u8&gt;, year: u64): Record {
        Record { name, author, year }
    }
}
</code></pre>
<p>What happens if we use module <code>RecordsCollection</code> in a script and call a method <code>add_new()</code>? New struct will be created in a script context. What happens when script scope ends? All defined variables and structs will be dumped:</p>
<pre><code class="language-Move">use {{sender}}::RecordsCollection as Collection;

fun main(name: vector&lt;u8&gt;, author: vector&lt;u8&gt;, year: u64) {

    let r = Collection::create_record(name, author, year);

    // record is created but it saved somewhere?
    // where does it go when script ends? nowhere!
}
</code></pre>
<p>Going further: even if we created <code>Collection</code> struct and pushed newly created <code>Record</code> in it, whole collection would still have been gone by the end of scope.</p>
<blockquote>
<p>That's when the <strong><code>resource struct</code></strong> comes into play. It can be saved, accessed,  updated and destroyed. It outlives the script and affects blockchain state.</p>
</blockquote>
<h2><a class="header" href="#how-to-work-with-resource" id="how-to-work-with-resource">How to work with <code>resource</code></a></h2>
<p>Let's modify our example with RecordsCollection (imagine we want to store our catalogue in blockchain). Even better - we will let anyone manage their record collection.</p>
<h2><a class="header" href="#make-struct-a-resource-struct" id="make-struct-a-resource-struct">Make <code>struct</code> a <code>resource struct</code></a></h2>
<p>First order of business - turning <code>struct</code> into <code>resource struct</code>. We will do it only for collection (you'll see why):</p>
<pre><code class="language-Move">resource struct Collection {
    records: vector&lt;Record&gt;
}
</code></pre>
<p>Even better (or say more correct) way to name main resource in module is <code>&quot;T&quot;</code>:</p>
<pre><code class="language-Move">// since whole module is named RecordsCollection
// everyone will understand that T equals Collection
resource struct T {
    records: vector&lt;Record&gt;
}
</code></pre>
<!-- MB rewrite this part later when done with structure; -->
<p>As you can see, nothing but an addition of one keyword. What actually happens? Collection remains a type. Just like struct you can initialize it (in resource-specific way), you can push records into it and (!) what's really important: this <code>resource struct</code> will be saved on chain linked to your address making it possible to read and change it again in future transactions. Even more! If module is properly organized, you can even let other people see your collection, and (only if you want to do so!) you can let them add records into your collection.</p>
<!-- END;  -->
<p>TLDR; It's time to code!</p>
<p>Move has 5 built-in functions to work with collections, we'll go through all of them in order.</p>
<h2><a class="header" href="#attach-resource-with-move_to_sender" id="attach-resource-with-move_to_sender">Attach resource with <code>move_to_sender</code></a></h2>
<p>To start working with resource, you need it to be attached to sender. Please keep in mind that the only place where you can manage <code>structs</code> and <code>resources</code> is their module. You can't init resource outside the module context but you can provide <code>public</code> method. That's how you do it:</p>
<pre><code class="language-Move">module RecordsCollection {

    use 0x0::Vector;

    // -- some definitions skipped --

    resource struct T {
        records: vector&lt;Record&gt;
    }

    public fun initialize() {
        move_to_sender&lt;T&gt;(T { records: Vector::empty() })
    }
}
</code></pre>
<blockquote>
<p>Function <code>move_to_sender&lt;RESOURCE&gt;(RESOURCE)</code> links resource to account. It uses some internal magic to define transaction sender so there's no need to specify one.</p>
</blockquote>
<h2><a class="header" href="#check-if-resource-exists-at-given-address" id="check-if-resource-exists-at-given-address">Check if resource <code>exists</code> at given address</a></h2>
<p>It's good to initialize resource once but not to be mistaken and not to inizalize it twice we can check if resource is linked to address. Here's how it looks if we modify previously defined <code>initialize()</code> function:</p>
<pre><code class="language-Move">module RecordsCollection {

    // -- some definitions skipped --

    use 0x0::Transaction as Tx;

    public fun initialize() {
        let sender = Tx::sender();

        if (!exists&lt;T&gt;(sender)) {
            move_to_sender&lt;T&gt;(T { records: Vector::empty() })
        }
    }
}
</code></pre>
<blockquote>
<p>Function <code>exists&lt;RESOURCE&gt;(&lt;ADDRESS&gt;): bool</code> checks if resource is linked to address and returns boolean result. You can use this function to check any resource and any address - this information is meant to be public on blockchain.</p>
</blockquote>
<h2><a class="header" href="#using-existing-resources-with-acquires" id="using-existing-resources-with-acquires">Using existing resources with <code>acquires</code></a></h2>
<p>Before we proceed. There is a huge difference between <em>using</em> resource and <em>checking or initializing</em> it. When you initialize resource you create a link between newly created resource, when you check existence you actually check this link exists. But when you <em>read</em>, <em>modify</em> or <em>destroy</em> resource, you need to actually <strong>use resource</strong>.</p>
<p>That is when keyword <code>acquires</code> appears. If your function <em>reads</em>, <em>modifies</em> or <em>destroys</em> resource, you MUST put this keyword. Here's how:</p>
<pre><code class="language-Move">module RecordsCollection {

    // here's our resource T
    resource struct T {
        records: vector&lt;Record&gt;
    }

    // and here we're going to read our resource T
    public fun get_my_records(): vector&lt;Record&gt; acquires T {
        // ...
    }
</code></pre>
<blockquote>
<p>Keyword <code>acquires</code> is put only in function definition after return value or parentheses (when function has no return value). Resource names <em>acquired</em> by this function have to be listed after. If there're multiple resources, use comma-separated list: <code>fun my_fun() acquires R1, R2</code>.</p>
</blockquote>
<p>Functions requiring <code>acquire</code>:</p>
<ul>
<li>borrow_global_mut</li>
<li>borrow_global</li>
<li>move_from</li>
</ul>
<h2><a class="header" href="#read-resource-contents-with-borrow_global" id="read-resource-contents-with-borrow_global">Read resource contents with <code>borrow_global</code></a></h2>
<p>Okay, we've already linked resource to sender account and even protected ourselves from double initialization, it's time to learn to read it.</p>
<pre><code class="language-Move">module RecordsCollection {

    // -- some definitions skipped --

    use 0x0::Transaction as Tx;

    resource struct T {
        records: vector&lt;Record&gt;
    }

    public fun get_my_records(): vector&lt;Record&gt; acquires T {

        let sender = Tx::sender();
        let collection = borrow_global&lt;T&gt;(sender);

        *&amp;collection.records
    }
}
</code></pre>
<blockquote>
<p>Function <code>borrow_global&lt;RESOURCE&gt;(&lt;ADDRESS&gt;): &amp;&lt;RESOURCE&gt;</code> requests immutable reference to resource at given address. You can read resource contents just how you'd normally read struct's.</p>
</blockquote>
<h2><a class="header" href="#modify-resource-with-borrow_global_mut" id="modify-resource-with-borrow_global_mut">Modify resource with <code>borrow_global_mut</code></a></h2>
<p>We've come a long way to get here, and finally we're ready to learn how to modify resource.</p>
<pre><code class="language-Move">module RecordsCollection {

    // -- some definitions skipped --

    use 0x0::Transaction as Tx;
    use 0x0::Vector;

    resource struct T {
        records: vector&lt;Record&gt;
    }

    public fun add_record(
        name: vector&lt;u8&gt;,
        author: vector&lt;u8&gt;,
        year: u64
    ) acquires T {

        let sender = Tx::sender();

        // not to do additional call let's put it here
        initialize(sender);

        let record = Record { name, author, year };
        let collection = borrow_global_mut&lt;T&gt;(sender);

        Vector::push_back(&amp;mut collection.records, record)
    }
}
</code></pre>
<blockquote>
<p>Function <code>borrow_global_mut&lt;RESOURCE&gt;(&lt;ADDRESS&gt;): &amp;mut &lt;RESOURCE&gt;</code> creates mutable reference to resource at given address. All the changes you apply via this mutable reference are going to be stored on chain.</p>
</blockquote>
<h2><a class="header" href="#remove-resource-with-move_from" id="remove-resource-with-move_from">Remove resource with <code>move_from</code></a></h2>
<p>Finally, to destroy our RecordCollection we will use <code>move_from</code> method.</p>
<pre><code class="language-Move">module RecordsCollection {

    // -- some definitions skipped --

    resource struct T {
        records: vector&lt;Record&gt;
    }

    // see return value here, it is important!
    public fun destroy_collection(): T acquires T {

        let sender = Tx::sender();

        move_from&lt;T&gt;(sender)
    }
}
</code></pre>
<p>Even though it looks simple - it's not. <code>move_from</code> is the most tricky of all methods in this article. Let's go through rules:</p>
<ol>
<li>Value returned by <code>move_from</code> MUST be used; it can also be desctructured!</li>
<li>You can't destroy resource twice as there's no resource on your account;</li>
<li>Value returned by <code>move_from</code> is a full (non-reference) instance of resource.</li>
</ol>
<p>That's it. Let's summarise.</p>
<blockquote>
<p>To remove resource from address use <code>move_from&lt;RESOURCE&gt;(&lt;ADDRESS&gt;): &lt;RESOURCE&gt;</code> method. Returned value MUST be used (eg passed as return value of destroy function).</p>
</blockquote>
<h2><a class="header" href="#final-contract" id="final-contract">Final contract</a></h2>
<p>Here's final contract. What it does:</p>
<ul>
<li>allows anyone store their own RecordCollection on chain;</li>
<li>provides security for RecordCollection - only owner can access it.</li>
</ul>
<pre><code class="language-Move">module RecordsCollection {

    use 0x0::Transaction as Tx;
    use 0x0::Vector;

    struct Record {
        name:   vector&lt;u8&gt;,
        author: vector&lt;u8&gt;,
        year:   u64
    }

    resource struct T {
        records: vector&lt;Record&gt;
    }

    fun initialize(sender: address) {
        if (!::exists&lt;T&gt;(sender)) {
            move_to_sender&lt;T&gt;(T { records: Vector::empty() })
        }
    }

    public fun add_record(
        name: vector&lt;u8&gt;,
        author: vector&lt;u8&gt;,
        year: u64
    ) acquires T {

        let sender = Tx::sender();

        initialize(sender);

        let record = Record { name, author, year };
        let collection = borrow_global_mut&lt;T&gt;(sender);

        Vector::push_back(&amp;mut collection.records, record)
    }

    public fun get_my_records(): vector&lt;Record&gt; acquires T {
        let sender = Tx::sender();
        let collection = borrow_global&lt;T&gt;(sender);

        *&amp;collection.records
    }

    public fun remove_from_me(): T acquires T {
        move_from&lt;T&gt;(Tx::sender())
    }
}
</code></pre>
<h2><a class="header" href="#list-of-functions-for-resource" id="list-of-functions-for-resource">List of functions for resource</a></h2>
<p>For reference here's list of methods:</p>
<pre><code class="language-Move">exists&lt;T&gt;(&lt;ADDRESS&gt;);  // check if resource exists at given address
move_to_sender&lt;T&gt;(T);  // move newly created resource to sender

// ones below require `acquires` keyword:

borrow_global&lt;T&gt;(&lt;ADDRESS&gt;);
borrow_global_mut&lt;T&gt;(&lt;ADDRESS&gt;);
move_from&lt;T&gt;(&lt;ADDRESS&gt;); // destroy resource
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
