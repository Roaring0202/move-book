<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Move Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> The Move Language</a></li><li class="chapter-item expanded "><a href="introduction/foreword.html"><strong aria-hidden="true">2.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="introduction/move.or.mvir.html"><strong aria-hidden="true">3.</strong> Move or Mvir</a></li><li class="chapter-item expanded "><a href="chapters/syntax-basics.html"><strong aria-hidden="true">4.</strong> Syntax Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapters/concept.html"><strong aria-hidden="true">4.1.</strong> Script and Module</a></li><li class="chapter-item expanded "><a href="chapters/primitives.html"><strong aria-hidden="true">4.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="chapters/comments.html"><strong aria-hidden="true">4.3.</strong> Comments</a></li><li class="chapter-item expanded "><a href="chapters/expression-block.html"><strong aria-hidden="true">4.4.</strong> Expression</a></li><li class="chapter-item expanded "><a href="chapters/control-flow.html"><strong aria-hidden="true">4.5.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="chapters/function.html"><strong aria-hidden="true">4.6.</strong> Function</a></li><li class="chapter-item expanded "><a href="chapters/imports.html"><strong aria-hidden="true">4.7.</strong> Import</a></li><li class="chapter-item expanded "><a href="chapters/struct.html"><strong aria-hidden="true">4.8.</strong> Structures</a></li></ol></li><li class="chapter-item expanded "><a href="chapters/advanced-topics.html"><strong aria-hidden="true">5.</strong> Advanced Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapters/references.html"><strong aria-hidden="true">5.1.</strong> References</a></li><li class="chapter-item expanded "><a href="chapters/generics.html"><strong aria-hidden="true">5.2.</strong> Generics</a></li><li class="chapter-item expanded "><a href="chapters/vector.html"><strong aria-hidden="true">5.3.</strong> Vector</a></li><li class="chapter-item expanded "><a href="chapters/resource.html"><strong aria-hidden="true">5.4.</strong> Resource</a></li></ol></li><li class="chapter-item expanded "><a href="ide/index.html"><strong aria-hidden="true">6.</strong> Move IDE</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ide/setting-up.html"><strong aria-hidden="true">6.1.</strong> Install &amp; Configure</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Move Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#move-language" id="move-language">Move Language</a></h1>
<p>Move is a safe and reliable language developed for blockchains by <a href="https://libra.org/">Libra</a>. You can read language white paper on <a href="https://developers.libra.org/docs/assets/papers/libra-move-a-language-with-programmable-resources/2019-09-26.pdf">libra developers website</a>.</p>
<p>This book (or call it a resource for now) is a collection of all the information that me and my colleagues found and shaped into a single collection of knowledge about Move language.</p>
<h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<p>It's been few months since we at <a href="https://dfinance.co">dfinance</a> started working with Libra's Move VM and Move language. Before that we worked a lot with blockchains (and smart contracts specifically): you may know our <a href="http://wings.ai">Wings.ai</a> project - once the biggest dApp on ETH network; and we - better than many - know how hard it can be for a newcomer to work with new blockchain language, especially Rust-like, especially when blockchain environments and infrastructure challenges come to play. </p>
<p>That is why we are here - to help you dive into yet unknown language, and to show you its beauty.</p>
<h1><a class="header" href="#move-or-mvir" id="move-or-mvir">Move or Mvir</a></h1>
<p>If you've tried searching any information on Move language or if you have visited <a href="https://developers.libra.org">developers.libra.org</a>, you may have noticed that there're 2 languages right now: Move - the one from whitepaper and fancy news headlines, and Mvir (Move IR) - most documented and mentioned on libra's developers portal.</p>
<p>Why are there two languages? Do they compile/transpile into each other? Is Move IR a middle step between Move and bytecode? The short answer is no. However long answer will require some explanation - let's start with the facts:</p>
<ol>
<li>There's only one VM (which is also called Move VM);</li>
<li>There're two compilers, hence two languages;</li>
</ol>
<p>From what we've known from calibra team, Move IR is a &quot;developer version&quot; of Move which was created to speed up VM development while &quot;the Move language&quot; was being designed. Even though these two languages have different syntax - both compile into bytecode which is supported by Move VM.</p>
<p>You may be asking yourself &quot;what should I choose?&quot;, well currently there's no correct answer to that. Move is Rust-like and simpler, Mvir is pretty hardcore when it comes to references and changes of values; both are supported by VM. According to <a href="https://developers.libra.org/blog/">Libra's blog</a>:</p>
<ol>
<li>New syntax from latest blog posts <a href="https://libra.org/en-US/blog/how-to-use-the-end-to-end-tests-framework-in-move/">looks like Move</a>;</li>
<li><a href="https://libra.org/en-US/blog/libra-core-roadmap-3/">In roadmap #2 retrospective</a> Libra team marks Move IR as a tooling language and separates Move IR and Move language;</li>
</ol>
<p>We can only suggest using Move as primary as in long perspective it's propably going to be &quot;the Move&quot;. Though, as we've already mentioned, nobody can be sure at this point.</p>
<p>In this book you will only meet Move (with some remarks on Mvir and their difference), as I believe it is going to be the final Move language.</p>
<h1><a class="header" href="#syntax-basics" id="syntax-basics">Syntax Basics</a></h1>
<p>In this chapter you'll get to know Move language. We'll start with very simple and basic grammar rules and intensity will increase from one chapter to another. If you're a skilled developer this may seem too easy at first glance, but I do recommend you to take a closer look. If you're a beginner, then this part will give you everything you need to know about Move basics.</p>
<h1><a class="header" href="#script-and-module" id="script-and-module">Script and Module</a></h1>
<p>There are two types of code transactions in Move: module and script. Module is a deployment of new module (which then will be accessible under the address of sender); Script is a transaction-as-code in which you can use deployed modules as well as the standard library as dependencies.</p>
<p>Module code starts with <code>module</code> keyword and its code looks like this. Inside module you can define: new <em>types</em> (as structs), <em>methods</em> and <code>resource structs</code>.</p>
<pre><code class="language-Move">module MyModule {
    struct hi_fives {
        count: u8
    }

    public fun high_five(): u8 {
        5
    }
}
</code></pre>
<p>Script must contain <code>main</code> function and usually uses deployed modules. See <a href="chapters//move-language-reference/imports.html">imports</a> on how to import modules.</p>
<pre><code class="language-Move">script {
    // assume that sender address was 0xAF
    use {{sender}}::MyModule;

    fun main() {
        MyModule::high_five();
    }
}
</code></pre>
<h1><a class="header" href="#primitive-types" id="primitive-types">Primitive Types</a></h1>
<p>In this section you'll find examples and short descriptions of Move's primitive types: integers (u8, u64, u128), <code>boolean</code> and <code>address</code>. You will also learn how to change size of integer values and what types of addresses are supported in different versions of Move VM.</p>
<!-- MB ADD NODE: Also, there are no floating point types or strings. -->
<h2><a class="header" href="#integer-types" id="integer-types">Integer types</a></h2>
<p>Integers are represented by <code>u8</code>, <code>u64</code> and <code>u128</code>; Possible integer notations are:</p>
<pre><code class="language-Move">fun main() {
    // define empty variable, set value later
    let a: u8;
    a = 10;

    // define variable, set type
    let a: u64 = 10;

    // finally simple assignment
    let a = 10;

    // simple assignment with defined value type
    let a = 10u128;

    // in function calls or expressions you can use ints as constant values
    if (a &lt; 10) {};

    // or like this, with type
    if (a &lt; 10u8) {}; // usually you don't need to specify type
}
</code></pre>
<h3><a class="header" href="#operator-as" id="operator-as">Operator <code>as</code></a></h3>
<p>When you need to compare values or when function argument requires integer of different size you can cast your integer variable to another size by using operator <code>as</code>:</p>
<pre><code class="language-Move">fun main() {
    let a: u8 = 10;
    let b: u64 = 100;

    // we can only compare same size integers
    if (a == (b as u8)) abort 11;
    if ((a as u64) == b) abort 11;
}
</code></pre>
<h2><a class="header" href="#boolean" id="boolean">Boolean</a></h2>
<p>Boolean type is just the one you're used to. Two constant values: <code>false</code> and <code>true</code> - both can only mean one thing - a value of <code>bool</code> type.</p>
<pre><code class="language-Move">fun main() {
    // these are all the ways to do it
    let b : bool; b = true;
    let b : bool = true;
    let b = true
    let b = false; // here's an example with false
}
</code></pre>
<h2><a class="header" href="#address" id="address">Address</a></h2>
<p>Address is identifier of sender (or wallet) in blockchain. The very basic operations which require address type are sending coins and importing module.</p>
<pre><code class="language-Move">fun main() {
    let addr: address; // type identifier

    // in this book I'll use {{sender}} notation;
    // always replace `{{sender}}` in examples with VM specific address!!!
    addr = {{sender}};

    // in Libra's Move VM - 16-byte address in HEX
    addr = 0x...;

    // in dfinance's DVM - bech32 encoded address with `wallet1` prefix
    addr = wallet1....;
}
</code></pre>
<h1><a class="header" href="#comments" id="comments">Comments</a></h1>
<p>If you feel like some places in your code require additional explanation, use <em>comments</em>. Comments are non-executable blocks or lines of text aimed to describe some pieces of the code.</p>
<h3><a class="header" href="#line-comments" id="line-comments">Line comments</a></h3>
<pre><code class="language-Move">script {
    fun empty() {
        // this is a comment line
    }
}
</code></pre>
<p>You can use double-slash &quot;<em>//</em>&quot; to write line comments. Rules are simple - <strong>everything after</strong> &quot;<em>//</em>&quot; is considered a comment to the end of line. You can use line comments to leave short notes for other developers or to <em>comment out</em> some code to remove it from execution chain.</p>
<pre><code class="language-Move">script {
    // let's add a note to everything!
    fun check_this(): u8 {
        let a = 10;
        // let b = 10 this line is commented and won't be executed
        let b = 5; // here comment is placed after code
        a + b // result is 15, not 10!
    }
}
</code></pre>
<h3><a class="header" href="#block-comments" id="block-comments">Block comments</a></h3>
<p>If you don't want to comment all the line contents, alternatively if you want to comment out more than one line you can use block comments.</p>
<p>Block comment starts with slash-asterisk <em>/*</em> and includes all the text before first asterisk-slash <em>*/</em>. Block comment is not limited by one line and gives you power of making a note in absolutely any place in code.</p>
<pre><code class="language-Move">script {
    fun /* you can comment everywhere */ notes(): u8 {
        /* here
           there
           everywhere */ let a = 10;
        let b = /* even here */ 10; /* and again */
        a + b
    }
    /* you can use it to remove certain expressions or definitions
    fun empty_commented_out() {

    }
    */
}
</code></pre>
<p>Of course this example is ridiculous! But it clearly shows the power of block comment. Feel free to comment anywhere!</p>
<h1><a class="header" href="#expression" id="expression">Expression</a></h1>
<p>In programming languages expressions is a unit of code which returns a value. A function call with return value is an expression - it returns value, an integer literal is an expression - it has the value of this integer and so on.</p>
<h3><a class="header" href="#simple-expressions" id="simple-expressions">Simple expressions</a></h3>
<p>Look at the code below. What do you see? What is an expression from the definition and what is not?</p>
<pre><code class="language-Move">fun main(): u8 {
    let a = 10;
    let b;
    b = a;
    (a + b)
}
</code></pre>
<p>Remember keyword <code>let</code> from <a href="chapters//chapters/primitives.html">primitives chapter</a>? It creates new variable and assigns it a value of expression which has to be put right after equality (or <em>assignment</em>) sign.</p>
<p>In this example <code>10</code> is an expression (an integer literal) which returns 10. Variable <code>a</code> was created and assigned a value - 10.</p>
<h1><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h1>
<p>In terms of control operators Move's syntax is similar to Rust with some differences which I'll highlight.</p>
<p>Let's start with one simple rule:</p>
<blockquote>
<p>Every expression MUST end with semicolon unless it's the last expression in scope</p>
</blockquote>
<p>Which means that every <code>loop</code>, every <code>while</code> and <code>if</code> expressions - all of them MUST have semicolon at the end if any expression goes after. Not having semicolon (like in Rust) will result in syntax error.</p>
<h2><a class="header" href="#the-if-expression" id="the-if-expression">The <code>if</code> expression</a></h2>
<p>If you want to run code block when some expression is <code>true</code> you need to use <code>if</code> keyword:</p>
<pre><code class="language-Move">script {
    use 0x0::Transaction;

    fun main(custom_addr: address) {
        if (custom_addr != Transaction::sender()) {
            abort 11
        };

        // alternatively
        if (custom_addr != Transaction::sender()) abort 11
    }
}
</code></pre>
<p>Syntax:</p>
<pre><code class="language-Move">if (&lt;EXPRESSION&gt;) &lt;EXPRESSION&gt;;
</code></pre>
<h3><a class="header" href="#lets-add-else-to-our-ifs" id="lets-add-else-to-our-ifs">Let's add <code>else</code> to our <code>if</code>s!</a></h3>
<p>You can (and sometimes must) add <code>else</code> to your <code>if</code> construction:</p>
<pre><code class="language-Move">script {
    use 0x0::Transaction;

    fun main(custom_addr: address) {
        if (custom_addr != Transaction::sender()) {
            abort 11
        } else {
            let _ = true
        };

        // alternatively
        if (custom_addr != Transaction::sender()) abort 11 else {
            let _ = true
        };
    }
}
</code></pre>
<p>Syntax with <code>else</code>:</p>
<pre><code class="language-Move">if (&lt;EXPRESSION&gt;)
    &lt;EXPRESSION&gt;
else
    &lt;EXPRESSION&gt;;
</code></pre>
<h2><a class="header" href="#using-loops" id="using-loops">Using loops</a></h2>
<p>In Move you have two ways to do repetition: conditional loop with <code>while</code> and infinite <code>loop</code>.</p>
<p>Use while loop with bool expression inside parentheses:</p>
<pre><code class="language-Move">fun main() {

    let i = 0;

    while (i &lt; 5) {
        i = i + 1;
    }
}
</code></pre>
<p>For infinite (non-conditional) loops use <code>loop</code> keyword with expression:</p>
<pre><code class="language-Move">fun main() {
    let i = 0;

    loop {
        i = i + 1;
        if (i == 5) break
    }
}
</code></pre>
<p>Syntax for loops:</p>
<pre><code class="language-Move">while (&lt;EXPRESSION&gt;) &lt;EXPRESSION&gt;;
loop &lt;EXPRESSION&gt;;
</code></pre>
<h3><a class="header" href="#control-loops-with-continue-and-break" id="control-loops-with-continue-and-break">Control loops with <code>continue</code> and <code>break</code></a></h3>
<p>Keywords <code>continue</code> and <code>break</code> allow you to skip one round or break iteration.</p>
<p>For example let's add two conditions into <code>loop</code>. If <code>i</code> is even we use <code>continue</code> to jump to next iteration without going through code after <code>continue</code> call.
With <code>break</code> we stop iteration and exit loop.</p>
<pre><code class="language-Move">fun main() {
    let i = 0;

    loop {
        i = i + 1;

        if (i / 2 == 0) continue;
        if (i == 5) break;

        // assume we do something here
    };

    // i here is 5
}
</code></pre>
<p>About semicolons. If <code>break</code> and <code>continue</code> are the last keywords in scope, you can't put a semicolon after them as any code after won't be executed. Somehow even semi can't be put. See this:</p>
<pre><code class="language-Move">fun main() {
    let i = 0;

    loop {
        i = i + 1;

        if (i == 5) {
            break; // will result in compiler error. correct is `break` without semi
                   // Error: Unreachable code
        }

        // same with continue here: no semi, never;
        if (true) {
            continue
        }

        // however you can put semi like this, because continue and break here
        // are single expressions, hence they &quot;end their own scope&quot;
        if (true) continue;
        if (i == 5) break;
    }
}
</code></pre>
<h1><a class="header" href="#function" id="function">Function</a></h1>
<p>Function is the only place of execution in Move. Functions start with <code>fun</code> keyword which is followed by function name, parentheses for arguments and curly braces for body.</p>
<p>You've already seen few in previous chapters. And now you will learn how to use them.</p>
<h3><a class="header" href="#functions-in-script-context" id="functions-in-script-context">Functions in script context</a></h3>
<p>Let's try to write few functions and see what we can do. We'll start with script context as it's fairly simple.</p>
<pre><code class="language-Move">script {
    fun gimme_five(): u8 {
        5
    }
}
</code></pre>
<p>We defined our first <code>gimme_five</code> function with no arguments and return value of <code>u8</code> type. It's obvious that in this function return value (remember <a href="chapters//chapters/expression-blocks">expressions</a>!) is always 5.</p>
<p>Let's look at a different example and see how we can use <em>function arguments</em>.</p>
<h3><a class="header" href="#function-arguments-and-return-values" id="function-arguments-and-return-values">Function arguments and return values</a></h3>
<pre><code class="language-Move">script {
    fun empty() {
    }

    fun sum(a: u8, b: u8): u8 {
        a + b
    }
}
</code></pre>
<p>Here we've created <code>sum</code> function with two arguments inside parentheses: <em>a</em> and <em>b</em>. Let's learn few rules:</p>
<ol>
<li>Function arguments MUST have types specified and MUST be separated by comma;</li>
<li>Function return value (if there is one) is put after parentheses and requires a colon;</li>
</ol>
<p>Now how would we call function <code>sum</code>? Here's a sample.</p>
<pre><code class="language-Move">script {
    fun sum(a: u8, b: u8): u8 {
        a + b
    }

    fun gimme_five_and_five(): u8 {
        let ten = sum(5, 5);
        ten
    }
}
</code></pre>
<h3><a class="header" href="#function-body" id="function-body">Function body</a></h3>
<p>In this example we've defined another function <em>gimme_five_and_five()</em> which takes no arguments and makes a call to function <em>sum</em> with two fives as arguments. In return it gets 10 and returns this value to the caller. Returned type of our function-caller matches return type of function <em>sum</em>.</p>
<p>In Move only function body can contain expressions and statements. It is impossible to do an assignment or create a loop outside of the function context.</p>
<pre><code class="language-Move">script {
    fun sum_iterator(iter: u8, n: u8): u8 {

        let i = 0;
        let res = 0;
        while (i &lt; iter) {
            res = res + n;
            i = i + 1;
        };

        res
    }
}
</code></pre>
<p>We can surely say that none of the statements you see inside the body of function <em>sum_iterator</em> can be used outside function context. Try it yourself - there's no point in life without mistakes!</p>
<h3><a class="header" href="#multiple-return-values" id="multiple-return-values">Multiple return values</a></h3>
<p>In previous examples we've experimented with functions with no return value or with single. But what if I told you that you can return multiple values of any type. Curious? Let's proceed!</p>
<p>To specify multiple return values you need to use parentheses:</p>
<pre><code class="language-Move">script {
    fun max(a: u8, b: u8): (u8, bool) {
        if (a &gt; b) {
            (a, false)
        } else if (a &lt; b) {
            (b, false)
        } else {
            (a, true)
        }
    }
}
</code></pre>
<p>This function takes two arguments: <em>a</em> and <em>b</em> and also <strong>returns two values</strong>: first is the max value and second is a boolean whether numbers entered are equal. Take closer look at the syntax: instead of specifying singe return argument we've added <strong>parenteses</strong> and have listed return argument types.</p>
<p>Now let's see how we can use result of this function in <code>let</code> statement.</p>
<pre><code class="language-Move">script {
    // max function is defined ...
    fun main(): u64  {
        let (m, is_equal) = max(99, 100);

        if (is_equal) {
            m = m * 2;
        }

        (m as u64)
    }
}
</code></pre>
<p>In this example we've <em>destructed</em> a tuple: created two new variables with values and types of return values of function <em>max</em>. Order is preserved and variable <em>m</em> here gets type <em>u8</em> and now stores max value, whereas <em>is_equal</em> is a <em>bool</em>.</p>
<p>Two is not the limit - number of returned arguments is up to you, though you'll soon learn about structs and see alternative way to return complex data.</p>
<h3><a class="header" href="#functions-in-a-module" id="functions-in-a-module">Functions in a module</a></h3>
<h3><a class="header" href="#function-visibility" id="function-visibility">Function visibility</a></h3>
<h1><a class="header" href="#imports" id="imports">Imports</a></h1>
<p>Default context in Move is empty - you can't operate Vector, you can't access Transaction details and you can't do almost anything (with small exception of built-in functions which will also require some Account features). To make your module or a script more meaningful and useful you need imports.</p>
<p>Here we need to take a step back and go through concept again. As I've mentioned in previous part there're two types of code transactions: <em>module</em> and <em>script</em>. Module is <em>deployed</em> (or published) and can be imported and used in a script. Not only custom deployed modules can be imported. There's also the <em>Standard library</em> (accessible at address <code>0x0</code>) which significantly extends language functionality.</p>
<h2><a class="header" href="#senders-address" id="senders-address">Sender's address</a></h2>
<p>Every transaction on blockchain is sent and signed by its sender, hence every module you or someone else publish to blockchain has sender's address which can be used to access/import this module.</p>
<p>In modifications of Move VM any address format can be used, so not to misguide you and to make this book as basic and general as it can be, I will use <code>{{sender}}</code> pattern to mark sender's address.</p>
<h2><a class="header" href="#keyword-use" id="keyword-use">Keyword <code>use</code></a></h2>
<p>To import module from address use this pattern:</p>
<pre><code class="language-Move">use {{sender}}::ModuleName;
</code></pre>
<p>In <code>module</code> context import MUST be placed inside module definition:</p>
<pre><code class="language-Move">module Lebowski {
    use {{sender}}::TheRug;

    public fun get_the_rug_back() {
        TheRug::tie_the_room_together();
    }
}
</code></pre>
<p>In <code>script</code> context import MUST be placed before <code>main()</code>.</p>
<pre><code class="language-Move">// script context
script {
    use {{sender}}::Lebowski;

    fun the_dude() {
        Lebowski::get_the_rug_back();
    }
}
</code></pre>
<h3><a class="header" href="#use-meets-as" id="use-meets-as"><code>use</code> meets <code>as</code></a></h3>
<p>You can change name of the imported module in your code using keyword <code>as</code>.</p>
<pre><code class="language-Move">script {
    use 0x0::Transaction as Tx;

    fun check_assert() {
        Tx::assert(true, 11);
    }
}
</code></pre>
<p>This may be used to shorten-up some dependencies or to resolve name conflicts between modules.</p>
<h2><a class="header" href="#importing-standard-library" id="importing-standard-library">Importing Standard library</a></h2>
<p>Standard library is always accessible via <code>0x0</code> address. It can be used in both <em>module</em> and <em>script</em>.</p>
<pre><code class="language-Move">module M {
    use 0x0::Transaction;

    public fun sender(): address {
        Transaction::sender()
    }
}
</code></pre>
<h1><a class="header" href="#struct" id="struct">Struct</a></h1>
<p>Structure is a custom type which contains complex data (or no data). It can be described as a simple key-value storage where key is a name of property and value is what's stored. Defined using keyword <code>struct</code>.</p>
<blockquote>
<p>Struct (and resource struct) is the only way to create custom type in Move. You'll learn more about it later.</p>
</blockquote>
<h2><a class="header" href="#rules" id="rules">Rules</a></h2>
<ol>
<li>Struct definition is possible <strong>only within a module</strong>;</li>
<li>Struct can contain field of any type including another structure;</li>
<li>Structs can only be constructed in the module in which they are declared;</li>
<li>Struct fields can only be accessed within module (therefore they are all private);</li>
<li>Recursive struct definition is impossible;</li>
<li>Struct may not have fields (can be empty).</li>
</ol>
<h2><a class="header" href="#definition-and-usage" id="definition-and-usage">Definition and Usage</a></h2>
<p>Again: <code>struct</code> can be defined only inside module context.</p>
<pre><code class="language-Move">module RecordsCollection {

    // struct can contain no fields it's
    // initialization will be simple:
    // let d = Dummy {};
    struct Dummy {}

    struct Record {
        author_id: u64,
        label_id: u64,
        year: u64,
        is_new: bool
    }

    // we can create new Record in a method
    public fun add_new(author_id: u64, label_id: u64, year: u64): Record {
        // when creating new struct use pattern:
        // &lt;key&gt;: &lt;value&gt;
        Record {
            author_id: author_id,
            label_id: label_id,
            year: year,
            is_new: true
        };

        // you can could also use short notation when variable
        // name matches name of the property
        let record: Record = Record {
            author_id,
            label_id,
            year,
            is_new: true
        };

        record
    }

    // since struct fields can only be accessed within module, you
    // have to provide interface to read structs if you pass it
    // outside of the module
    public fun print_year(r: Record): u64 {

        // to access struct's fields use &quot;.&quot; (dot) notation
        r.year
    }
}
</code></pre>
<p>Let's take a better look at <code>add_new(...)</code> function. Since struct is a new type, it can also be a return type, and you're able to see it in function definition:</p>
<pre><code class="language-Move">public fun add_new(author_id: u64, label_id: u64, year: u64): Record { /* ... */ }
</code></pre>
<p>Okay. How can we use our <code>Record</code> struct after we published <code>VinylShop</code> module into network?</p>
<pre><code class="language-Move">// specify publisher's address

script {
    use {{sender}}::VinylShop;

    fun add_new_record() {
        // we can use type-binding but we can't construct it - Rule #3
        let record : VinylShop::Record = VinylShop::add_new(10, 10, 1999);

        // here we can pass record type but can't use `record.year` - Rule #4
        if (VinylShop::print_year(record) == 1999) abort 11;
    }
}
</code></pre>
<h2><a class="header" href="#destruction" id="destruction">Destruction</a></h2>
<p>In some cases you may need to destroy your struct and get it's contents. This operation called destruction.</p>
<pre><code class="language-Move">module LongLive {

    struct T { value: u8 }

    public fun create(value: u8): T {
        T { value }
    }

    public fun destroy(t: T): u8 {
        let T { value } = T;
        value
    }
}
</code></pre>
<p>Syntax for destructuring is the opposite to creation:</p>
<pre><code>let T { &lt;field1&gt;, &lt;field...&gt; } = T;
</code></pre>
<h1><a class="header" href="#advanced-topics" id="advanced-topics">Advanced Topics</a></h1>
<h1><a class="header" href="#references" id="references">References</a></h1>
<h1><a class="header" href="#generics" id="generics">Generics</a></h1>
<h1><a class="header" href="#vector" id="vector">Vector</a></h1>
<p>Vector is a built-in (native) complex type for storing collection of values of one type.</p>
<h2><a class="header" href="#rules-1" id="rules-1">Rules</a></h2>
<p>As usual - let's start with rules.</p>
<ol>
<li>Vector is a native type (just like <a href="chapters//chapters/primitives.html">primitives</a>) which means you can use it in both modules and scripts;</li>
<li>Vector can only contain items of the same type. Which means you cannot store elements of type A and type B in the same vector;</li>
<li>Vector can have size from zero to 9,223,372,036,854,775,807 (max size of <code>u64</code>), it's called length;</li>
<li>Type of stored value is specified in generic: <code>vector&lt;Element&gt;</code>;</li>
<li>Since it's a native type, to use it you need standard library - usually <code>0x0::Vector</code>.</li>
</ol>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<p>As said above you can use it everywhere. In module:</p>
<pre><code class="language-Move">module Countries {
    struct Country {
        name: vector&lt;u8&gt;
    }

    resource struct CountriesList {
        value: vector&lt;Country&gt;
    }
}

</code></pre>
<p>And in script!</p>
<pre><code class="language-Move">script {

    use 0x0::Vector;

    fun vector_example() {
        let collection = Vector::empty&lt;u8&gt;();

        Vector::push_back&lt;u8&gt;(&amp;mut collection, 10);
    }
}
</code></pre>
<p>In this example we've created an empty vector of <code>u8</code> integers and filled it with one value. Please note that vector creation within code is only possible via <code>0x0::Vector</code> library since this type is native.</p>
<h2><a class="header" href="#0x0vector-module" id="0x0vector-module">0x0::Vector module</a></h2>
<p>To manage collection properly we'd need to be able to get its length, to access elements of this collection, and to modify its contents. All of this can be done with standard library (and only with standard library).</p>
<p>Here's a short list of methods available:</p>
<ul>
<li>Create an empty vector of type &lt;E&gt;</li>
</ul>
<pre><code class="language-Move">Vector::empty&lt;E&gt;(): vector&lt;E&gt;;
</code></pre>
<ul>
<li>Get length of a vector</li>
</ul>
<pre><code class="language-Move">Vector::length&lt;E&gt;(v: &amp;vector&lt;E&gt;): u64;
</code></pre>
<ul>
<li>Push element to the end of the vector:</li>
</ul>
<pre><code class="language-Move">Vector::push_back&lt;E&gt;(v: &amp;mut vector&lt;E&gt;, e: E);
</code></pre>
<ul>
<li>Get mutable reference to element of vector. For immutable borrow use <code>Vector::borrow()</code></li>
</ul>
<pre><code>Vector::borrow_mut&lt;E&gt;(v: &amp;mut vector&lt;E&gt;, i: u64): &amp;E;
</code></pre>
<ul>
<li>Pop an element from the end of vector:</li>
</ul>
<pre><code>Vector::pop_back&lt;E&gt;(v: &amp;mut vector&lt;E&gt;): E;
</code></pre>
<p>This list is just enough to start working with vector, but to know full potential of vector you must see these standard libraries:</p>
<ul>
<li>Libra <a href="https://github.com/libra/libra/blob/master/language/stdlib/modules/vector.move">libra/libra</a></li>
<li>Dfinance <a href="https://github.com/dfinance/dvm/blob/master/lang/stdlib/vector.move">dfinance/dvm</a></li>
</ul>
<h1><a class="header" href="#resources" id="resources">Resources</a></h1>
<p>Resources are what makes Move unique, safe and powerful.
First, let's see description from <a href="https://developers.libra.org/docs/move-overview#move-has-first-class-resources">libra developers portal</a>:</p>
<blockquote>
<ul>
<li>The key feature of Move is the ability to define custom resource types. <strong>Resource types are used to encode safe digital assets with rich programmability</strong>.</li>
<li><strong>Resources are ordinary values in the language</strong>. They can be stored as data structures, passed as arguments to procedures, returned from procedures, and so on.</li>
<li><strong>The Move type system provides special safety guarantees for resources</strong>. Move resources can never be duplicated, reused, or discarded. A resource type can only be created or destroyed by the module that defines the type. These guarantees are enforced statically by the Move virtual machine via bytecode verification. The Move virtual machine will refuse to run code that has not passed through the bytecode verifier.</li>
<li>The Libra currency is implemented as a resource type named LibraCoin.T. LibraCoin.T has no special status in the language; every Move resource enjoys the same protections.</li>
</ul>
</blockquote>
<h2><a class="header" href="#resource-concept" id="resource-concept">Resource concept</a></h2>
<p>Imagine you open a safe deposit box at the bank. Since it's a bank you trust it with alls the contents of your deposit box, and you know that bank will guard it and manage access policy correctly so you and only you (except special occasions in your agreement) can control contents of this deposit box.</p>
<p>What could be the properties of this deposit box?</p>
<ul>
<li>an owner - it is you</li>
<li>it's created for owner (you) by bank - trusted side</li>
<li>deposit box's access policy is managed by bank and you know it before signing</li>
<li>deposit box may contain anything - there's no limit</li>
<li>deposit box can be moved or destroyed by you or by bank (if your agreement allows it)</li>
<li>deposit box access may be shared (again - if it's specified in terms)</li>
</ul>
<p>That's pretty much what's going on in Move. Every resource is a deposit box and just like deposit box - it is user-specific. For each user deposit deal goes full path from creation (or <em>initialization</em>) to using (or <em>modification</em>) and optionally to <em>destruction</em>. I suggest you keep in mind this analogy as it will help you understand resource concept.</p>
<h2><a class="header" href="#resource-life-time" id="resource-life-time">Resource life time</a></h2>
<p>Resource in Move is defined as a <code>resource struct</code> and just like <code>struct</code> it can only be defined within module context, and unlike struct, resource will outlive your script. To understand that let's look at this example:</p>
<pre><code class="language-Move">// here's our module to manage records on chain
module RecordsCollection {

    use 0x0::Transaction as Tx;

    // the very basic information about our record
    struct Record {
        name: vector&lt;u8&gt;,
        author: vector&lt;u8&gt;,
        year: u64
    }

    // imaginary collection of records
    struct Collection {
        records: vector&lt;Record&gt;
    }

    public fun create_record(name: vector&lt;u8&gt;, author: vector&lt;u8&gt;, year: u64): Record {
        Record { name, author, year }
    }
}
</code></pre>
<p>What happens if we use module <code>RecordsCollection</code> in a script and call a method <code>add_new()</code>? New struct will be created in a script context. What happens when script scope ends? All defined variables and structs will be dumped:</p>
<pre><code class="language-Move">use {{sender}}::RecordsCollection as Collection;

fun main(name: vector&lt;u8&gt;, author: vector&lt;u8&gt;, year: u64) {

    let r = Collection::create_record(name, author, year);

    // record is created but it saved somewhere?
    // where does it go when script ends? nowhere!
}
</code></pre>
<p>Going further: even if we created <code>Collection</code> struct and pushed newly created <code>Record</code> in it, whole collection would still have been gone by the end of scope.</p>
<blockquote>
<p>That's when the <strong><code>resource struct</code></strong> comes into play. It can be saved, accessed,  updated and destroyed. It outlives the script and affects blockchain state.</p>
</blockquote>
<h2><a class="header" href="#how-to-work-with-resource" id="how-to-work-with-resource">How to work with <code>resource</code></a></h2>
<p>Let's modify our example with RecordsCollection (imagine we want to store our catalogue in blockchain). Even better - we will let anyone manage their record collection.</p>
<h2><a class="header" href="#make-struct-a-resource-struct" id="make-struct-a-resource-struct">Make <code>struct</code> a <code>resource struct</code></a></h2>
<p>First order of business - turning <code>struct</code> into <code>resource struct</code>. We will do it only for collection (you'll see why):</p>
<pre><code class="language-Move">resource struct Collection {
    records: vector&lt;Record&gt;
}
</code></pre>
<p>Even better (or say more correct) way to name main resource in module is <code>&quot;T&quot;</code>:</p>
<pre><code class="language-Move">// since whole module is named RecordsCollection
// everyone will understand that T equals Collection
resource struct T {
    records: vector&lt;Record&gt;
}
</code></pre>
<!-- MB rewrite this part later when done with structure; -->
<p>As you can see, nothing but an addition of one keyword. What actually happens? Collection remains a type. Just like struct you can initialize it (in resource-specific way), you can push records into it and (!) what's really important: this <code>resource struct</code> will be saved on chain linked to your address making it possible to read and change it again in future transactions. Even more! If module is properly organized, you can even let other people see your collection, and (only if you want to do so!) you can let them add records into your collection.</p>
<!-- END;  -->
<p>TLDR; It's time to code!</p>
<p>Move has 5 built-in functions to work with collections, we'll go through all of them in order.</p>
<h2><a class="header" href="#attach-resource-with-move_to_sender" id="attach-resource-with-move_to_sender">Attach resource with <code>move_to_sender</code></a></h2>
<p>To start working with resource, you need it to be attached to sender. Please keep in mind that the only place where you can manage <code>structs</code> and <code>resources</code> is their module. You can't init resource outside the module context but you can provide <code>public</code> method. That's how you do it:</p>
<pre><code class="language-Move">module RecordsCollection {

    use 0x0::Vector;

    // -- some definitions skipped --

    resource struct T {
        records: vector&lt;Record&gt;
    }

    public fun initialize() {
        move_to_sender&lt;T&gt;(T { records: Vector::empty() })
    }
}
</code></pre>
<blockquote>
<p>Function <code>move_to_sender&lt;RESOURCE&gt;(RESOURCE)</code> links resource to account. It uses some internal magic to define transaction sender so there's no need to specify one.</p>
</blockquote>
<h2><a class="header" href="#check-if-resource-exists-at-given-address" id="check-if-resource-exists-at-given-address">Check if resource <code>exists</code> at given address</a></h2>
<p>It's good to initialize resource once but not to be mistaken and not to inizalize it twice we can check if resource is linked to address. Here's how it looks if we modify previously defined <code>initialize()</code> function:</p>
<pre><code class="language-Move">module RecordsCollection {

    // -- some definitions skipped --

    use 0x0::Transaction as Tx;

    public fun initialize() {
        let sender = Tx::sender();

        if (!exists&lt;T&gt;(sender)) {
            move_to_sender&lt;T&gt;(T { records: Vector::empty() })
        }
    }
}
</code></pre>
<blockquote>
<p>Function <code>exists&lt;RESOURCE&gt;(&lt;ADDRESS&gt;): bool</code> checks if resource is linked to address and returns boolean result. You can use this function to check any resource and any address - this information is meant to be public on blockchain.</p>
</blockquote>
<h2><a class="header" href="#using-existing-resources-with-acquires" id="using-existing-resources-with-acquires">Using existing resources with <code>acquires</code></a></h2>
<p>Before we proceed. There is a huge difference between <em>using</em> resource and <em>checking or initializing</em> it. When you initialize resource you create a link between newly created resource, when you check existence you actually check this link exists. But when you <em>read</em>, <em>modify</em> or <em>destroy</em> resource, you need to actually <strong>use resource</strong>.</p>
<p>That is when keyword <code>acquires</code> appears. If your function <em>reads</em>, <em>modifies</em> or <em>destroys</em> resource, you MUST put this keyword. Here's how:</p>
<pre><code class="language-Move">module RecordsCollection {

    // here's our resource T
    resource struct T {
        records: vector&lt;Record&gt;
    }

    // and here we're going to read our resource T
    public fun get_my_records(): vector&lt;Record&gt; acquires T {
        // ...
    }
</code></pre>
<blockquote>
<p>Keyword <code>acquires</code> is put only in function definition after return value or parentheses (when function has no return value). Resource names <em>acquired</em> by this function have to be listed after. If there're multiple resources, use comma-separated list: <code>fun my_fun() acquires R1, R2</code>.</p>
</blockquote>
<p>Functions requiring <code>acquire</code>:</p>
<ul>
<li>borrow_global_mut</li>
<li>borrow_global</li>
<li>move_from</li>
</ul>
<h2><a class="header" href="#read-resource-contents-with-borrow_global" id="read-resource-contents-with-borrow_global">Read resource contents with <code>borrow_global</code></a></h2>
<p>Okay, we've already linked resource to sender account and even protected ourselves from double initialization, it's time to learn to read it.</p>
<pre><code class="language-Move">module RecordsCollection {

    // -- some definitions skipped --

    use 0x0::Transaction as Tx;

    resource struct T {
        records: vector&lt;Record&gt;
    }

    public fun get_my_records(): vector&lt;Record&gt; acquires T {

        let sender = Tx::sender();
        let collection = borrow_global&lt;T&gt;(sender);

        *&amp;collection.records
    }
}
</code></pre>
<blockquote>
<p>Function <code>borrow_global&lt;RESOURCE&gt;(&lt;ADDRESS&gt;): &amp;&lt;RESOURCE&gt;</code> requests immutable reference to resource at given address. You can read resource contents just how you'd normally read struct's.</p>
</blockquote>
<h2><a class="header" href="#modify-resource-with-borrow_global_mut" id="modify-resource-with-borrow_global_mut">Modify resource with <code>borrow_global_mut</code></a></h2>
<p>We've come a long way to get here, and finally we're ready to learn how to modify resource.</p>
<pre><code class="language-Move">module RecordsCollection {

    // -- some definitions skipped --

    use 0x0::Transaction as Tx;
    use 0x0::Vector;

    resource struct T {
        records: vector&lt;Record&gt;
    }

    public fun add_record(
        name: vector&lt;u8&gt;,
        author: vector&lt;u8&gt;,
        year: u64
    ) acquires T {

        let sender = Tx::sender();

        // not to do additional call let's put it here
        initialize(sender);

        let record = Record { name, author, year };
        let collection = borrow_global_mut&lt;T&gt;(sender);

        Vector::push_back(&amp;mut collection.records, record)
    }
}
</code></pre>
<blockquote>
<p>Function <code>borrow_global_mut&lt;RESOURCE&gt;(&lt;ADDRESS&gt;): &amp;mut &lt;RESOURCE&gt;</code> creates mutable reference to resource at given address. All the changes you apply via this mutable reference are going to be stored on chain.</p>
</blockquote>
<h2><a class="header" href="#remove-resource-with-move_from" id="remove-resource-with-move_from">Remove resource with <code>move_from</code></a></h2>
<p>Finally, to destroy our RecordCollection we will use <code>move_from</code> method.</p>
<pre><code class="language-Move">module RecordsCollection {

    // -- some definitions skipped --

    resource struct T {
        records: vector&lt;Record&gt;
    }

    // see return value here, it is important!
    public fun destroy_collection(): T acquires T {

        let sender = Tx::sender();

        move_from&lt;T&gt;(sender)
    }
}
</code></pre>
<p>Even though it looks simple - it's not. <code>move_from</code> is the most tricky of all methods in this article. Let's go through rules:</p>
<ol>
<li>Value returned by <code>move_from</code> MUST be used; it can also be desctructured!</li>
<li>You can't destroy resource twice as there's no resource on your account;</li>
<li>Value returned by <code>move_from</code> is a full (non-reference) instance of resource.</li>
</ol>
<p>That's it. Let's summarise.</p>
<blockquote>
<p>To remove resource from address use <code>move_from&lt;RESOURCE&gt;(&lt;ADDRESS&gt;): &lt;RESOURCE&gt;</code> method. Returned value MUST be used (eg passed as return value of destroy function).</p>
</blockquote>
<h2><a class="header" href="#final-contract" id="final-contract">Final contract</a></h2>
<p>Here's final contract. What it does:</p>
<ul>
<li>allows anyone store their own RecordCollection on chain;</li>
<li>provides security for RecordCollection - only owner can access it.</li>
</ul>
<pre><code class="language-Move">module RecordsCollection {

    use 0x0::Transaction as Tx;
    use 0x0::Vector;

    struct Record {
        name:   vector&lt;u8&gt;,
        author: vector&lt;u8&gt;,
        year:   u64
    }

    resource struct T {
        records: vector&lt;Record&gt;
    }

    fun initialize(sender: address) {
        if (!::exists&lt;T&gt;(sender)) {
            move_to_sender&lt;T&gt;(T { records: Vector::empty() })
        }
    }

    public fun add_record(
        name: vector&lt;u8&gt;,
        author: vector&lt;u8&gt;,
        year: u64
    ) acquires T {

        let sender = Tx::sender();

        initialize(sender);

        let record = Record { name, author, year };
        let collection = borrow_global_mut&lt;T&gt;(sender);

        Vector::push_back(&amp;mut collection.records, record)
    }

    public fun get_my_records(): vector&lt;Record&gt; acquires T {
        let sender = Tx::sender();
        let collection = borrow_global&lt;T&gt;(sender);

        *&amp;collection.records
    }

    public fun remove_from_me(): T acquires T {
        move_from&lt;T&gt;(Tx::sender())
    }
}
</code></pre>
<h2><a class="header" href="#list-of-functions-for-resource" id="list-of-functions-for-resource">List of functions for resource</a></h2>
<p>For reference here's list of methods:</p>
<pre><code class="language-Move">exists&lt;T&gt;(&lt;ADDRESS&gt;);  // check if resource exists at given address
move_to_sender&lt;T&gt;(T);  // move newly created resource to sender

// ones below require `acquires` keyword:

borrow_global&lt;T&gt;(&lt;ADDRESS&gt;);
borrow_global_mut&lt;T&gt;(&lt;ADDRESS&gt;);
move_from&lt;T&gt;(&lt;ADDRESS&gt;); // destroy resource
</code></pre>
<h1><a class="header" href="#move-ide" id="move-ide">Move IDE</a></h1>
<p>Currently there're only few text editors with support of Move language (through extensions or packages). Those are:</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=SDKBox.vscode-libra-move">VSCode Move Language</a> - supports only Mvir, <strong>outdated</strong></li>
<li><a href="https://atom.io/packages/language-move">Atom Language Move</a> - mostly Mvir, hardly Move</li>
</ul>
<p>And the best of all at the moment: <a href="https://marketplace.visualstudio.com/items?itemName=damirka.move-ide">Move IDE for VSCode</a></p>
<h2><a class="header" href="#features" id="features">Features</a></h2>
<p>As an active Move enthusiast and a guy who wrote 2 out of 3 currently available packages for Move language I gurarantee you that Move IDE for VSCode is the best option you've got. Let's see what's inside:</p>
<ul>
<li>Full syntax support for both Move and Mvir;</li>
<li><a href="https://github.com/dfinance/move-language-server">Move Language Server</a> integrated into IDE which provides error highlights, code verification and import checks</li>
<li>Fully customizable environment for your projects with ability to set custom Move dialect, use different versions of Standard Library or compiler within the directory</li>
<li>It provides you with standard of organizing your Move project and aims to make this standard true</li>
</ul>
<h2><a class="header" href="#install" id="install">Install</a></h2>
<ul>
<li>If you don't have VSCode - <a href="https://code.visualstudio.com/download">get it here</a>!</li>
<li>Go to <a href="https://marketplace.visualstudio.com/items?itemName=damirka.move-ide">VSCode Extensions Marketplace</a> and press INSTALL button or find it in your VSCode by the <strong>Move IDE</strong> name and install there.</li>
<li>Thoroughly read and follow instructions in <a href="https://github.com/damirka/vscode-move-ide#move-ide-for-vscode">README</a> or just scroll down...</li>
</ul>
<h2><a class="header" href="#setting-up-your-environment" id="setting-up-your-environment">Setting up your environment</a></h2>
<p>TBD</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
